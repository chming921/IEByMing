# java基础

## **面向对象和面向过程**

**面向过程**：性能高，类调用时需要实例化，开销大，消耗资源，当性能为主要考虑因素时，一般使用面向过程，如单片机、嵌入式，**注重实现过程**

**面向对象**：易维护、易复用、易扩展，因为面向对象有封装、继承、多态的特性，所以可以设计出低耦合的系统，是系统更加灵活、易于维护，但是面向对象性能				   比面向过程低

## 封装的目的是什么，为什么要有封装？

封装是面向对象编程语言**对客观世界的模拟**，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：

- **隐藏类的实现细节**；
- 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；
- 可进行数据检查，从而有利于保证对象信息的完整性；
- **便于修改**，提高代码的可维护性。

## JAVA语言特点

简单易学  

面向对象   

一次编译，到处运行   

可靠性  

安全性   

支持多线程

编译与解释并存：java语言经过java编译器（jdk中的javac）编译之后得到.class文件（字节码文件），就是java文件到虚拟机的中间码，然后JVM（不同平台对应的）加载.class文件，3然后通过解释器逐行解释



**编译型语言：**注重编译，它是指将文件通过编译器一次性编译成特定平台（操作系统）可以运行的机器码。

**解释性语言：**使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成					   翻译。

## 一个Java文件里可以有多个类吗（不含内部类）？

1. 一个java文件里**可以有多个类**，但最多**只能有一个被public修饰的类**；
2. 如果这个java文件中包含**public修饰的类**，则这个**类的名称必须和java文件名**一致。

## JVM

运行java字节码的虚拟机，针对不同系统的特点实现，目的是使用相同的字节码，给出相等的结果。

********什么是字节码？有什么好处？********

JVM可以理解的代码（.class文件），不面向任何处理器，只面向虚拟机。

java通过字节码的形式，在一定程度上解决了传统语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

由于**字节码并不针对一种特定的机器**，因此java程序**不用重复编译便可在不同的操作系统的计算机**上运行



 Java程序从源代码到运行一般有下面3步：

![image-20220331210935092](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220331210935092.png)

从.class文件到可执行的二进制机器码的过程中，JVM有两种方式，一种是解释器，另一种时**JIT编译器**，热点程序会走JIT编译器，否则走**解释器**



## JDK和JRE

**JDK是Java Development Kit**  java开发工具包    **JRE+开发工具包(java javac jar)**

包含JRE，还有编译器、java工具

**JRE(java runtime environment)是java运行时环境**，**运行已编译java程序所需的所有内容的集合**，包括**虚拟机**（jvm）、**java类库**   **JVM+核心类库**

只运行，JRE即可，要编译就要JDK



## [值传递](https://so.csdn.net/so/search?q=值传递&spm=1001.2101.3001.7020)和引用传递

**值传递(pass by value)：**在调用函数时，将**实际参数复制一份**传递到函数中，这样在函数中对参数进行修改，就**不会影响到原来的实际参数**；

**引用传递(pass by reference):**在调用函数时，将**实际参数的地址直接传递到函数**中。这样**在函数中对参数进行的修改，就会影响到实际参数**；

第一个例子：

```java
public class Hello {
    public static void main(String[] args) {
        Hello hello = new Hello();
        // 基本数据类型
        int i = 10;
        hello.pass(i);
        System.out.println("i = " + i);
    }
    
    public void pass(int pas) {
    pas = 20;
    System.out.println("pas = " + pas);
	}
}
```

运行结果：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/20201109135406361.png)

通过运行结果，可以看出这个例子是比较好理解的一个值传递的例子。

第二个例子：

```java
public class Hello {
    public static void main(String[] args) {
        Hello hello = new Hello();
        // String类
        String s = "hello";
        hello.pass(s);
        System.out.println("s = " + s);
    }
public void pass(String str) {
    str = "world";
    System.out.println("str = "+ str);
	}
}
```

运行结果：

![img](https://img-blog.csdnimg.cn/2020110913591779.png)

通过运行结果可以看出值也是发生了变化的，但是调用函数对String类赋值的时候【str = "world";】相当于是【str = new String("world");】;我这里理解是变量str重新指向了一个新的对象的地址。

第三个例子：

```java
public class Hello {
    public static void main(String[] args) {
        Hello hello = new Hello();
        // 对象
        User user = new User();
        user.setName("wang");
        hello.pass(user);
        System.out.println("main:"+user.getName());
    }
public void pass(User user) {
    user.setName("java");
    System.out.println("The name is :" + user.getName());
	}
}
```

运行结果：

![img](https://img-blog.csdnimg.cn/20201109140707901.png)

看到这个例子的时候，便是我最大疑问的时候，当时我便觉得在Java中基本数据类型是值传递，对象数据类型是引用传递，而String看做一个特殊的类。在看下一个例子；

第四个例子：

```java
public class Hello {
    public static void main(String[] args) {
        Hello hello = new Hello();
        User user2 = new User();
        user2.setName("li");
        hello.pass2(user2);
        System.out.println("main:"+user2.getName());
    }
public void pass2(User user) {
    user = new User();
    user.setName("java new");
    System.out.println("The name is :" + user.getName());
	}
}
```

运行结果：

![img](https://img-blog.csdnimg.cn/2020110914104720.png)

看到这个例子的时候，你在想想第二个例子，我发现其实他们的输出的结果最后发生了改变，是因为重新new了一个新对象的原因，他们原有的对象并没有发生任何的改变。然后我们再重新看一下值传递和引用传递的定义，重新调整一下思路：

我觉得对于基本数据来说，在进行传递的时候， 将数据的值复制了一份进行的传递，所以我们也比较好理解的这种值传递；而对于对象数据类型，因为该对象本身指向的是它在内存中的地址，所以方法调用的时候，实际上是**创建的地址的副本**，所以**在方法中对其值进行改变的时候，他的地址没有变，值也就跟着改变了**；而当你**重新创建一个对象的时候，它指向的便是另一个对象的地址**了。这样看来跟值传递的定义便不冲突了。

总之，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。



## Java和C++的区别

同：都是面向对象的语言，支持封装、继承、多态

异：

1. java**不提供指针操作**，程序**内存更加安全**
2. java的**类是单继承**的，C++可以多继承，但是Java**可以实现多个接口**
3. java有**自动内存管理机制**，不需要程序员手动释放无用内存。

Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。

## 字符型常量和字符串常量的区别

形式上，字符型常量是**单引号**引起的一个字符；字符串常量是**双引号**引起的若干字符。

含义上，字符型常量相当于一个**整型**(**ASCII码**)，可以参加表达式计算；字符串常量代表一个**地址值**（**表示该字符串在地址中的存放位置**）

占内存大小，**字符型常量只占两个字节**，**字符串常量占若干字节**

| **数据类型** | byte | short |   char   | int  | float | double | boolean | long |
| :----------: | :--: | :---: | :------: | :--: | :---: | :----: | :-----: | :--: |
|   占用空间   |  1   | **2** |    2     |  4   |   4   |   8    |         |  8   |
|    初始值    |  0   |   0   | '\u0000' |  0   | 0.0F  |  0.0   |  false  |  0L  |

逻辑上boolean型只占1bit，但是虚拟机底层对boolean值进行操作实际使用的是int型，操作boolean数组则使用byte型。

int类型占4字节（32位），数据范围是 -2^31 ~ 2^31-1。

## 请介绍全局变量和局部变量的区别

Java中的变量分为**成员变量**和**局部变量**，它们的区别如下：

**成员变量：**

1. 成员变量是在**类的范围里定义的变量**；
2. 成员变量有**默认初始值**；
3. **未被static修饰**的成员变量也叫**实例变量**，它存储于**对象所在的堆内存中，生命周期与对象相同**；
4. **被static修饰**的成员变量也叫**类变量**，它存储于**方法区中**，**生命周期与当前类相同**。

**局部变量：**

1. 局部变量是在**方法里定义的变量**；
2. 局部变量**没有默认初始值**；
3. 局部变量存储于**栈内存中**，作用的范围结束，变量空间会自动的释放。

Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。

## float与double/short与int

float f = 1.1; 错

float f = 1.1f; 对

short s = 1；  s+=1;

s = s+1;错   s++;(隐式类型转换 相当于s = (short)(s + 1);)   隐式类型转换由小到大可以转，反过来会损失精度

## java集合机制与使用场景

```java
Collection
一组对立的元素，通常这些元素都服从某种规则
    1.1 List必须保持元素特定的顺序
    	1.1.1 ArrayList
    	1.1.2 Vector
    	1.1.3 LinkedList
    1.2 Set不能有重复元素
    	1.2.1 HashSet（为快速查找设计）
    		1.2.1.1 LinkedHashSet
    	1.2.2 SortSet
    		1.2.2.1 TreeSet（使得有序）
    1.3 Queue保持一个队列（先进先出）的顺序
    	1.3.1 PriorityQueue（模拟堆，按照元素顺序排序）
    	1.3.2 Deque
2 Map
一组成键值对的对象
    2.1 HashMap
    2.2 HashSet
    2.3 SortedMap
    	2.3.1 TreeMap(基于红黑树排序)
    2.4 ...
```



## 构造器Constructor可否被Override（重写）

构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。

构造器**不可以被重写，可以被重载**

**重写**

子类对父类允许访问的方法的实现过程重新编写

1. **返回值类型、方法名、参数列表**必须相同
2. 如果父类的方法修饰符为**private static final**，子类不能重写该方法
3. **构造方法不能被重写**
4. 子类返回值类型(**仅当返回值类型为类时**)要比父类方法返回值类型更小或相等，子类声明抛出的异常应比父类方法声明抛出的异常更小或相等
5. 子类方法的访问权限应比父类方法的访问权限更大或相等

**重载**

发生在一个类中，**方法名必须相同**，**参数类型不同**、**个数不同、顺序不同**，**方法返回值和访问修饰符可以不同**

## Student s = new Student()

- 载入Student.class文件进内存（方法区）
- 在**栈内存**为s开辟空间
- 在**堆内存**为学生对象开辟空间
- 对学生对象的成员变量进行**默认初始化**
- 对学生对象的成员变量进行**显式初始化**    **显式初始化即为手工给予初值，否则为隐式初始化，将内容设置为默认值。**
- 通过构造方法对学生对象的成**员变量赋值**
- 学生对象初始化完成，把**对象地址赋值给s变量**

![image-20220601165936249](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220601165936249.png)

### 说一说你对Java访问权限的了解

Java语言为我们提供了三种访问修饰符，即**private、protected、public**，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即**private、default、protected、public**，注意在不加任何修饰符时为default访问权限。

在**修饰成员变量/成员方法**时，该成员的四种访问权限的含义如下：

- private：该成员可以被该类内部成员访问；
- default：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；
- protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问；
- public：该成员可以被任意包下，任意类的成员进行访问。

在**修饰类**时，该类只有两种访问权限，对应的访问权限的含义如下：

- default：该类可以被同一包下其他的类访问；
- public：该类可以被任意包下，任意的类所访问。

## 封装、继承、多态

### **封装：**

将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的访问

好处：

1. **只能通过规定的方法访问数据**
2. **隐藏该类的实例细节，方便修改和实现**

**访问修饰符**

![image-20220331215954183](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220331215954183.png)



**java中的内部类**

内部类就是**定义在一个类里面的类**。与之对应，包含内部类的类被称为外部类

内部类的作用：

1. 提供了**更好的封装**，可以把**内部类隐藏在外部类之内**，**不允许同一个包的其它类访问该类**
2. 内部类的方法可以**直接访问外部类的所有数据**，包括**私有的数据**
3. 内部类能实现的功能外部类也可以实现，有时内部类更容易实现

内部类分类：

1. 成员内部类
2. 静态内部类
3. 方法内部类
4. 匿名内部类

### **继承：**

子类继承父类，可以拥有父类所有的属性和方法（除了**private修饰的属性不能拥有**），从而实现了代码的复用

#### 重写

子类如果对继承的父类方法不满意，可以重写自己继承的方法，调用该方法时优先调用子类的方法

#### 初始化顺序

父类对象属性初始化  ->父类对象构造方法->子类对象属性初始化->子类对象构造方法

#### Final关键字

1. 修饰类，不许被**继承**
2. 修饰方法，不许被**重写**
3. 修饰属性，只能**在初始化或者构造方法赋值**
4. 修饰变量

**final修饰变量：**

final修饰成员变量：

- 类变量：可以在**声明变量时指定初始值**，也可以在**静态初始化块中指定初始值**；
- 实例变量：可以在**声明变量时指定初始值**，也可以在**初始化块或构造方法中指定初始值**；

final修饰局部变量：

- 可以在**声明变量时指定初始值**，也可以在**后面的代码中指定初始值**。

*注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！*

### 多态

因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。

当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass();，这个obj引用变量的**编译时类型是BaseClass**，而**运行时类型是SubClass**，当**运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征**，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。

父类或接口的引用变量可以指向子类或具体实现类的实例对象，然后编译的时候不知道指针指向哪里，等到运行时才知道，从而指向对应的子类或者接口具体实现的类所指向的方法。

多态是对象的多种形态，由于对象不同可能会有不同的行为，比如都是休息，张三可能是爬山，李四可能是睡觉，用一个父类去执行方法。

1. **引用多态：**父类引用指向子类对象

​						   父类引用指向本类对象

**引用类型转换**

**向上类型转换** 小类型转换为大类型

```java
Dog dog = new Dog();
Animal animal = dog;
```

**向下类型转换**（强制类型转换）大类型转换为小类型，有风险，可能会数据溢出

```java
Dog dog = new Dog();
Animal animal = dog;
Dog dog2 = animal;
```

如果父类没有引用子类，是不能向下类型转换的，虽然**编译器不报错，但是运行会出错**

```java
Dog dog = (Dog)new Animal();
```

**如果父类引用已经指向一个子类，那么不可以再转为其他类**

```java
Dog dog = new Dog();
Animal animal = dog;
Dog dog2 = animal;
Cat cat = (Cat)animal;   //编译时Cat类型   运行时Dog类型
```

因为**程序animal开辟的是Dog类型的内存空间，这与Cat类型内存空间不匹配，所以无法正常转换。**

**instanceof**运算符

**测试他左边的对象是否是它右边的类的实例**，返回boolean类型的数据。

```java
if(animal instanceof Cat)
	Cat cat = animal;
```

2. **方法多态：**

​			当我们父类的引用指向不同的子对象时，他们**调用的方法也是多态**的。

​			创建**本类对象**时，调用的方法为**本类方法**；

​			创建**子类对象**时，调用的方法为**子类重写的方法或者继承的方法**；

​			但是多态使用的时候应该注意：**如果子类编写了一个父类不存在的方法，那么就不能通过父类的引用来调用这个方法。**

​			注意：**继承是多态的基础**

## 泛型

### 说一说你对泛型的理解

Java集合有个缺点—把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当**再次取出该对象**时，**该对象的编译类型就变成了Object类型**（其运行时类型没变）。

Java集合之所以被设计成这样，是因为集合的设计者**不知道我们会用集合来保存什么类型的对象**，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：

- **集合对元素类型没有任何限制**，这样可能引发一些问题。例如，想**创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。**
- 由于**把对象“丢进”集合**时，**集合丢失了对象的状态信息**，只知道它盛装的是Object，因此取出集合元素后通常还需要进行**强制类型转换**。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。

从Java 5开始，Java引入了“参数化类型”的概念，允许程序在**创建集合时指定集合元素的类型**，Java的参数化类型被称为泛型（Generic）。例如 List<String>，表明该List只能保存字符串类型的对象。

有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而**无须对集合元素进行强制类型转换。**

### 介绍一下泛型擦除

当把一个**具有泛型信息的对象赋给另一个没有泛型信息的变量**时，所有在**尖括号之间的类型信息都将被扔掉**。比如一个 List<String> 类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（即Object）。

上述规则即为泛型擦除，可以通过下面代码进一步理解泛型擦除：

```java
List<String> list1 = ...; List list2 = list1; // list2将元素当做Object处理
```

从逻辑上来看，List<String> 是List的子类，如果直接把一个List对象赋给一个List<String>对象应该引起编译错误，但实际上不会。对泛型而言，**可以直接把一个List对象赋给一个 List<String> 对象**，编译器仅仅提示“未经检查的转换”。

上述规则叫做泛型转换，可以通过下面代码进一步理解泛型转换：

```java
List list1 = ...; List<String> list2 = list1; // 编译时警告“未经检查的转换”
```

### List<? super T>和List<? extends T>有什么区别？

- ? 是类型通配符，List<?> 可以表示各种泛型List的父类，意思是元素类型未知的List；
- List<? super T> 用于**设定类型通配符的下限**，此处 ? 代表一个未知的类型，但它**必须是T的父类型**；
- List<? extends T> 用于**设定类型通配符的上限**，此处 ? 代表一个未知的类型，但它**必须是T的子类型**。

在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<Integer> 对象赋值给 List<Number> 变量。

数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但G<Foo> 不是 G<Bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，**Java的数组支持型变，但Java集合并不支持型变**。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。



## 抽象类和接口

### 抽象类

类前用abstract关键字修饰，则该类为抽象类

使用抽象类注意：

	1. 抽象类只是规定子类必须有什么方法，而不知道具体如何实现这些方法
	1. 可以从多个具有相同特征的类中抽象出一个抽象类，作为模板。

- 抽象类**定义方法，只是声明，不需实现**。
- 抽象类中也**可以包含**其他**普通的方法**，可以没有抽象方法。
- 抽象类不能直接创建实例化，需要定义引用变量指向子类对象，来实现抽象方法
- 可以有构造方法

### 接口

一种特殊的类，有全局变量和公共的抽象方法组成

规定实现类必须要有哪些方法，不知道具体如何实现

**为什么要有？**

Java中一个类只能继承一个父类，不够灵活，可以实现多个接口。

注意**继承父类必须在实现接口之前**，即extends必须在implements之前

接口和匿名内部类配合使用：

![img](https://img-blog.csdnimg.cn/20210424141347805.png)

![img](https://img-blog.csdnimg.cn/20210424141350579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

### 区别

相同点：

 1、都不能被实例化。

 2、接口的实现类和抽象类的子类只有**全部实现了接口或者抽象类中的方法**后**才可以被实例化**。

 不同点：

 1、**接口只能定义**抽象方法不能实现方法，**抽象类**既可以定义抽象方法，也**可以实现方法**。

 2、单继承，多实现。接口可以实现多个，只能继承一个抽象类。

 3、**接口强调的是功能，抽象类强调的是所属关系**。

 4、接口中的所有成员变量为**public static final**， **静态不可修改，当然必须初始化**。抽象类可以和普通类一样任意类型。

 5、接口中的所有方法都是**public abstract**公开抽象的。而且**不能有构造方法**。抽象类就比较自由了，和普通的类差不多，可以有抽象方法也可以没有，可以有正常的方法，也可以没有。

## String、StringBuffer、StringBuilder

### String

### String类有哪些方法？

String类是Java最常用的API，它包含了大量处理字符串的方法，比较常用的有：

- char **charAt**(int index)：返回指定索引处的字符；
- String **substring**(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；
- String[] **split**(String regex)：以指定的规则将此字符串分割成数组；
- String **trim**()：删除字符串前导和后置的空格；
- int **indexOf**(String str)：返回子串在此字符串首次出现的索引；
- int **lastIndexOf**(String str)：返回子串在此字符串最后出现的索引；
- boolean **startsWith**(String prefix)：判断此字符串是否以指定的前缀开头；
- boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；
- String **toUpperCase**()：将此字符串中所有的字符大写；
- String toLowerCase()：将此字符串中所有的字符小写；
- String **replaceFirst**(String regex, String replacement)：用指定字符串替换第一个匹配的子串；
- String **replaceAll**(String regex, String replacement)：用指定字符串替换所有的匹配的子串。

String类中使用final关键字修饰字符数组char[]，所以String对象不可变

- Java 9之前字符串采用**char[]**数组来保存字符，即 private final char[] value；
- Java 9做了改进，采用**byte[]**数组来保存字符，即 private final byte[] value；

为什么设置为不可变？

- 用来**存储敏感信息，如账号，密码，网络路径，文件处理等场景里**，保证字符串 String 类的安全性就尤为重要了，如果**字符串是可变的，容易被篡改**，无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。
- 在**多线程中，只有不变的对象和值是线程安全的**，可以在多个线程中共享数据。由于 **String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用**，访问的都是同样的字符串数据，不需要任何同步操作。
- 字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于**字符串 hashcode 属性不会变更，保证了唯一性**，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。
- 当字符串不可变时，**字符串常量池才有意义**。字符串常量池的出现，可以**减少创建相同字面量的字符串**，让不同的引用指向池中同一个字符串，为运行时**节约很多的堆内存**。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。

**不可变好处：**缓存hash值（使得hash值不变，只进行一次计算）、string pool需要、线程安全、参数安全性（网络连接、参数变了、以为连接主机变了）

![image-20220602105932170](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220602105932170.png)

```java
String str1 = new String("123");   //在常量池创建一个”123“对象，遇到new在堆内存创建一个对象，并返回堆中的对象引用
String str2 = "123";  //因为之前常量池中能找到”123“对象，所以直接将引用返回，不创建新的
String str3 = str1.intern();   //若常量池中包含了str1字符串”123“，则直接返回引用，否则就在池中先创建一个，再返回池中的对象引用。
System.out.println((str1 == str2) + "," + (str3 == str2))
//false,true
String str4 = new String("234");
String str5 = new String("234");
String str6 = str4.intern();
String str7 = str5.intern();
System.out.println((str4 == str5) + "," + (str6 == str7));
//false,true
```

### StringBuffer和StringBuilder

都是继承**AbstractStringBuilder**类，其中**char[]**没有被final修饰，所以这两种对象都是可变的

通过提供的**append()、insert()、reverse()、setCharAt()、setLength()**等方法可以改变这个字符串对象的字符序列，一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的**toString()**方法将其转换为一个String对象。

### 线程安全

String不可变，可以理解为常量，因此线程安全。

**StringBuffer加了同步锁**，**线程安全**

StringBuilder没有对方法加**同步锁**，因此非线程安全

### 性能

String修改的时候都需要新生成一个String对象，然后将指针指向新的String对象。

StringBuilder和StringBuffer都会对自己操作，不会更改指针指向，StringBuilder性能更好，但冒着线程不安全的风险。

### 总结

1. 操作**少量**的数据：使用String
2. **单线程**操作字符串缓冲区下操作**大量**数据：使用StringBuilder
3. **多线程**操作字符串缓冲区下操作**大量**数据：使用StringBuffer

### 使用字符串时，new和""推荐使用哪种方式？

先看看 "hello" 和 new String("hello") 的区别：

- 当Java程序直接使用 "hello" 的字符串直接量时，JVM将会使用常量池来管理这个字符串；
- 当使用 new String("hello") 时，JVM会先使用常量池来管理 "hello" 直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。

显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般**建议使用直接量**的方式创建字符串。

### 说一说你对字符串拼接的理解

拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。

1. **\+ 运算符**：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；
2. StringBuilder：如果**拼接的字符串中包含变量**，并**不要求线程安全**，则适合使用StringBuilder；
3. StringBuffer：如果**拼接的字符串中包含变量**，并且**要求线程安全**，则适合使用StringBuffer；
4. String类的**concat**方法：如果**只是对两个字符串进行拼接**，并且**包含变量**，则适合使用concat方法；

采用 + 运算符拼接字符串时：

- 如果拼接的都是字符串直接量，则在编译时编译器会将其**直接优化为一个完整的字符串**，和你直接写一个完整的字符串是一样的，所以效率非常的高。
- 如果**拼接的字符串中包含变量**，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。但如果这个**拼接操作是在循环中**进行的，那么**每次循环编译器都会创建一个StringBuilder实例**，再去拼接字符串，相当于执行了 new StringBuilder().append(str)，所以此时效率很低。

采用StringBuilder/StringBuffer拼接字符串时：

- StringBuilder/StringBuffer都有字符串缓冲区，**缓冲区的容量在创建对象时确定，并且默认为16**。当**拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。**
- 缓冲区**频繁的扩容会降低拼接的性能**，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。

采用String类的**concat**方法拼接字符串时：

- concat方法的拼接逻辑是，**先创建一个足以容纳待拼接的两个字符串的字节数组**，然后先后**将两个字符串拼到这个数组里**，最后**将此数组转换为字符串**。
- 在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以只拼2个字符串时建议优先选择concat方法。////

1. **+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。**
2. **+左右可以为null，concat为会空指针。**
3. 如果**拼接空字符串，concat会稍快**，在速度上两者可以忽略不计，如果**拼接更多字符串建议用StringBuilder**。
4. 从字节码来看**+号编译后就是使用了StringBuiler来拼接**，所以**一行+的语句就会创建一个StringBuilder**，多条+语句就会创建多个，

## 自动装箱和拆箱

Java中的**基本数据类型没有方法和属性**，但是在特定场景下，我们必须要利用对象的相关属性，而**包装类就是为了让基本数据类型拥有方法和属性，实现对象化交**

**互**。这就是我们要学习的自动装箱与拆箱。

装箱：将基本类型用他们对应的引用类包装起来；

拆箱：将引用类型转换为基本数据类型；

通过自动装箱、自动拆箱功能，可以**大大简化基本类型变量和包装类对象之间的转换过程**。比如，某个方法的参数类型为包装类型，**调用时我们所持有的数据却是基本类型的值**，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。

```java
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;

        Integer one=new Integer(100);
        Integer two=new Integer(100);
        System.out.println(i1==i2);   //1
        System.out.println(i3==i4);   //2    
        System.out.println(one==two);  //3
        System.out.println(i1==100);   //4
        System.out.println(i1==one);   //5
    }
    
//1，true，上面的代码中i1和i2的数值为100，且被Integer包装类包装起来，因此直接从IntegerCache私有静态类的Integer数组中取已经存在的对象。

//2，false，这里很多同学容易出错，上面的代码中i3和i4的数值为200，根据IntegerCache私有静态类的源码可以发现，当数值不在[127~Integer.MAX_VALUE - (-low) -1]即[-128,127]之间时，便会创建新的Integer对象。因此这里i3和i4是两个不同对象，因此为false。

//3，false，这里就很好理解了，因为new Integer(100);创建了两个不同的对象，==比较的是内存地址。

//4，true，这里其实包含两个步骤：1， Integer i1 = 100;进行装箱；2，i1==100自动进行了拆箱，因此这里是两个基本数据类型进行比较，值必然相同。

//5，false，i1对象进行了装箱，其是直接从IntegerCache私有静态类的Integer数组中取已经存在的对象。而one是创建了一个新的对象，因此两者的内存地址必然不相同。
```

## 包装类型和基本类型的区别

包装类型是**对象，拥有字段和方法**，可以很方便的调用一些基本的方法，初始值是**null**，而且可以用null代表空值，而**基本引用类型**只能用**0来代表初始值**

其次基本数据类型是**直接存储在栈**中，而包装类型是一个对象，**对象的引用变量是存储在栈中**，**存储了对象在堆中的地址**，对象的数据是存在堆中。

## 如何对Integer和Double类型判断相等？

Integer、Double不能直接进行比较，这包括：

- 不能用**==**进行直接比较，因为它们是**不同的数据类型**；
- 不能转为**字符串**进行比较，因为转为字符串后，**浮点值带小数点**，**整数值不带**，这样它们永远都不相等；
- 不能使用compareTo方法进行比较，虽然它们都有**compareTo方法**，但该方法**只能对相同类型进行比较**。

整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用==进行比较。

```java
Integer i = 100;
Double d = 100.00;
System.out.println(i.doubleValue() == d.doubleValue());
```

## int和Integer有什么区别，二者在做==运算时会得到什么结果？

int是基本数据类型，Integer是int的包装类。二者在做==运算时，**Integer会自动拆箱为int类型，然后再进行比较**。届时，如果**两个int值相等则返回true，否则就返回false。**

## **不可以在一个静态方法调用非静态方法成员**

静态方法**可以不通过对象调用**，所以静态方法里，**不能调用其他非静态变量**，也**不可以访问非静态变量成员**。

## **在java中定义一个无参构造函数的用处：**

java程序在**执行子类的构造方法的时候，会去调用父类特定的构造方法**，如果**没有，会去调用父类的空参构造函数**。所以**为了编译不报错**，**父类必须要加上无参构造方法。**

调用父类无参构造方法的目的是**帮助子类做初始化工作**。

## 对象实体与对象引用

对象**实体是在堆内存中**，对象**引用是在栈内存**，**一个对象可以被任意多个对象引用所引用**

## **构造方法有那些特性？**

1.**名字与类名相同**

2.**没有返回值**，但不能用void声明构造函数。

3.生成类的对象时**自动执行**，无需调用。



## 静态方法与实例方法有何不同

1.在外部调用静态方法时，可以使用“**类名.方法名**”的方式，也可以使用“**对象名.方法名**”的方式。而实例方法只能有后面这种方式。也就是说，调用静态方法可以无需创建对象。

2**.静态方法**在访问本类的成员的时候，**只允许访问静态成员**，而**不允许访问实例成员变量和实例方法**；实例方法则无此限制。



## ==与equals

**==判断两个对象地址是否相等**，判断是不是同一个对象（**基本数据类型是比较值**，**引用数据类型是比较内存地址**）

equals

判断两个对象是否相等

1. 类覆盖了equals()方法，比较两个对象内容是否相等
2. 类没有覆盖equals()方法， 等价于通过==来比较对象

**注：String中的equals()方法是重写过的**，Object的equals方法是比较对象的内存地址，而String的equals()方法是**比较对象的值**

​		当创建String对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用，如果没有就在常量池中重新创建		一个String，也就是a，b本身的地址是不同的，但指向内容是一样的。



## **hashCode与equals**

**hashCode**

hashCode()作用是获取哈希码，实际上是返回一个int整数。作用是确定该对象在哈希表中的索引位置。HashCode()是定义在Object类中的，所以涉及到对象我们就会用到这个方法，而且这个方法时本地方法，是用C或C++实现的，该方法通常用来把对象的物理地址转换为整数之后返回。

用散列表的原因是：查找对象的时候可以根据索引快速找到，时间复杂度是O（1）。

**为什么重写equals时必须重写hashCode方法？**

hashcode可以获得哈希码，确定该对象在哈希表中的索引位置

- **提高效率**“使用hashcode提前检验，定位，不用每次都equals方法比较，提高效率
- **保证没有重复对象出现**，确保hashmap去重性：假如只重写euqals方法，不重写hashcode，相同的对象hashCode不同，从而映射到不同下标下，hashMap无法保证去重。

如果两个对象相等，则hashCode一定也是相同的。两个对象相等，对两个对象分别调用equals方法都返回true。但是，两个对象有相同的hashcode值，他们也不一定是相等的。因此equals方法被覆盖过，则hashCode方法也必须被覆盖。这样才能保证相等。



## 线程、程序、进程

**程序：**含有指令和数据的文件，被存储在磁盘或者其他的数据存储设备中，是静态的代码

**进程**：**程序的一次执行过程**，是系统运行程序的基本单位，进程是动态的。系统**运行一个程序**是**一个进程从创建、运行到消亡的过程**。一个进程就是一个执行中的程序，同时，进程还占着某些系统资源如CPU时间、内存空间、文件、输入输出设备的使用权。程序在执行的时候，会被操作系统挂入内存中。

**线程：**比进程更小的执行单位，**一个进程在其执行的过程中会产生多个线程**。不同的是**多个线程共享一块内存空间和一组系统资源**，系统在产生一个线程，或是在各线程之间切换工作时，负担要比进程小得多。



**线程状态：**

![image-20220404205047389](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220404205047389.png)

进程的状态：

![image-20220404205107165](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220404205107165.png)

## 异常处理

所有异常有一个祖先**Throwable**类，其中有两个子类**Exception**（异常）和**Error**（错误）。Exception能被程序本身处理（try...catch），Error是无法处理的（只能尽量避免）。

**Exception**：**程序本身可以处理的异常**，可以通过catch来进行捕获。Exception又可以分为**执行异常（RuntimeException）**和**检查异常（Checked Exceptions）**两种。

RuntimeException类及其子类的实例被称为Runtime异常；

不是RuntimeException类及其子类的异常实例则被称为Checked异常。

**Error：**属于**程序无法处理**的错误，我们没有办法通过catch来进行捕获。例如，**Java虚拟机运行错误**、**虚拟机内存不够(OOM)**、**类定义错误**。这些异常发生时，		     Java虚拟机一般会选择线程终止。

常见异常：NullPointerException、IndexOutOfBoundsException、ClassNotFoundException、ClassCastException

![image-20220606105508474](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220606105508474.png)

**Throwable类常用方法：**

public string **getMessage**():返回异常发生时的简要描述

Public string **toString**():返回异常发生时的详细信息

Public string **getLocalizedMeassage**():返回异常对象的本地化信息。

Public void **printStackTrace**():在控制台上打印Throwable对象封装的异常信息

**以下三种特殊情况，finally块不会被执行：**

1.在try或finally用了**system.exit(int)**退出程序。

2.所有**线程死亡**

3.关闭CPU。

**在finally中return会发生什么？**

在通常情况下，**不要在finally块中使用return、throw等导致方法终止的语句**，一旦在finally块中使用了return、throw语句，将**会导致try块、catch块中的return、throw语句失效。**

当Java程序**执行try块、catch块时遇到了return或throw语句**，这两个语句都会导致该方法立即结束，但是**系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块**，如果**没有**finally块，程序**立即执行return或throw语句**，方法终止；如果**有finally块**，系统**立即开始执行finally块**。只有**当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句**；**如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。**

**按照如下三个步骤处理异常：**

1. **捕获异常**

   将**业务代码包裹在try块内部**，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，**JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。**

2. **处理异常**

   在**catch块中处理异常时，应该先记录日志**，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。

3. **回收资源**

   如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段**业务代码执行完毕后关闭这项资源**。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即**无论是否发生异常，finally块内的代码总会被执行。**

**java异常机制**

关于**异常处理**：

在Java中，处理异常的语句由try、catch、finally三部分组成。其中，**try块用于包裹业务代码**，**catch块用于捕获并处理某个类型的异常**，**finally块则用于回收资源**。当**业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，**因为无论是否发生异常，finally块一定会执行。

关于**抛出异常**：

当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。

关于**异常跟踪栈**：

程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法**向外传播**，首先传给**该方法的调用者**，再传给**上层调用者**，以此类推。**最终会传到main方法**，若依然没有得到处理，则**JVM会终止程序**，并打印异常跟踪栈的信息

## Throw和Throws的区别

throw关键字用在方法内部，只能用于**抛出一种异常**；throws关键字用在方法声明上，可以抛出多个异常，用来表示**该方法可能抛出的异常列表**

## **获取用键盘输入常用的方法**

**Scanner**

```java
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();
```

**BufferedReader**

```java
BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
str = buf.readLine();
```

## **Java中的IO流**

### 介绍一下Java中的IO流

**流向**：输入和输出流

**操作单元**：字节流和字符流

**担任角色**：节点流和处理流

**输入和输出流**

写文件输出流，读文件输入流

![image-20220404213519231](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220404213519231.png)

**字节流和字符流**

字节流是数据单位为**8位的字节**，字符流操作的是数据单位为**16位的字符**

**字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据**，但它**不支持直接写入或读取Unicode码元**；

**字符流通常处理文本数据**，它支**持写入及读取Unicode码元**。

**为什么要字符流**：Java中字符采用的是Unicode标准，在Unicode标准下，**一个英文为一个字节，一个中文是两个字节**。如果采用字节流一个一个读会出现乱码。有字符流才会在缓冲区根据编码规则进行编码成对应的字符。

java虚拟机转字节得到字符流，耗时，不知道编码类型还容易出现乱码，所以干脆提供字符流

**节点流和处理流  **

节点流：**直接操作数据读写的流类**。如FileInputStream

处理流：对一个**已存在的流**的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能，例如BufferedInputStream(缓冲字节流)

处理流和节点流应用了Java的**装饰者设计**模式。

![image-20220404220017171](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220404220017171.png)

在诸多的处理流中，**缓冲流**非常重要。为了减少程序与磁盘的交互(IO操作真的很浪费时间)

![image-20220404220344439](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220404220344439.png)

- 字节缓冲流：BufferedInputStream，BufferedOutputStream
- 字符缓冲流：BufferedReader，BufferedWriter

缓冲流的基本原理，是在**创建流对象时，会创建一个内置的默认大小的缓冲区数组**，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/3813D6FF51EAD282F3995515D9A61541.png)

根据命名很容易理解各个流的作用：

- 以File开头的文件流用于访问文件；
- 以ByteArray/CharArray开头的流用于访问内存中的数组；
- 以Piped开头的管道流用于访问管道，实现进程之间的通信；
- 以String开头的流用于访问内存中的字符串；
- 以Buffered开头的缓冲流，用于在读写数据时对数据进行缓存，以减少IO次数；
- InputStreamReader、InputStreamWriter是转换流，用于将字节流转换为字符流；
- 以Object开头的流是对象流，用于实现对象的序列化；
- 以Print开头的流是打印流，用于简化打印操作；
- 以Pushback开头的流是推回输入流，用于将已读入的数据推回到缓冲区，从而实现再次读取；
- 以Data开头的流是特殊流，用于读写Java基本类型的数据。

### 怎么用流打开一个大文件？

打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采用分次读取的方式。

1. 使用**缓冲流**。缓冲流内部维护了一个**缓冲区**，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它**每次会读取一批数据将缓冲区填满**，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备。
2. 使用**NIO**。NIO采用**内存映射文件**的方式来处理输入/输出，NIO将**文件或文件的一段区域映射到内存中**，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多。

### 说说NIO的实现原理

Java的NIO主要由三个核心部分组成：**Channel、Buffer、Selector**。

![在这里插入图片描述](C:/Users/chm/Desktop/Java学习/面经.assets/bc98759fec0e4c7caa333896cfc3fd0ftplv-k3u1fbpfcp-zoom-in-crop-mark3024000.awebp)



所有的IO在NIO中都从一个**Channel（通道）开始**，数据可以**读操作的时候从Channel读到Buffer中，也可以写操作时从Buffer写到Channel中**。Channel有好几种类型，其中比较常用的有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等，这些通道涵盖了UDP和TCP网络IO以及文件IO。

![nio-buffer-channel-selector](C:/Users/chm/Desktop/Java学习/面经.assets/1588158667.png)

**FileChannel**：文件通道，用于文件的读和写
**DatagramChannel**：用于 UDP 连接的接收和发送
**SocketChannel**：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端
**ServerSocketChannel**：TCP 对应的服务端，用于监听某个端口进来的请求

![nio-buffer-channel-selector](C:/Users/chm/Desktop/Java学习/面经.assets/1588158677.png)

![nio-buffer-channel-selector](C:/Users/chm/Desktop/Java学习/面经.assets/1588158692.png)

**Buffer**本质上是**一块可以写入数据，然后可以从中读取数据的内存**。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。Java NIO里关键的Buffer实现有**CharBuffer、ByteBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer**。这些Buffer覆盖了你能通过IO发送的基本数据类型，即byte、short、int、long、float、double、char。

其实核心是最后的 **ByteBuffer**，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。

我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。

Buffer对象包含三个重要的属性，分别是capacity、position、limit，其中position和limit的含义取决于Buffer处在读模式还是写模式。但不管Buffer处在什么模式，capacity的含义总是一样的。

- capacity：作为一个内存块，Buffer有个固定的最大值，就是capacity。Buffer**只能写capacity个数据**，一旦Buffer满了，需要将其清空才能继续写数据往里写数据。
- position：当**写数据**到Buffer中时，**position表示当前的位置**。初始的position值为0。当一个数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity–1。当**读取数据**时，也是从某个特定位置读。当**将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。**
- limit：在**写模式下**，Buffer的limit表示最多能往Buffer里写多少数据，此时**limit等于capacity**。当切换Buffer到**读模式时**， limit表示你最多能读到多少数据，此时limit会被设置成**写模式下的position值**。

三个属性之间的关系，如下图所示：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/242CC72B9020D2512E353D972261C386.png)

**Selector（多路复用）**允许**单线程处理多个 Channel**，如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件例如有新连接进来，数据接收等。

这是在一个单线程中使用一个Selector处理3个Channel的图示：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/3B9B608579DA2CD4624EDF11CFD343CF.png)

Java NIO根据操作系统不同， 针对NIO中的Selector有不同的实现：

- macosx：KQueueSelectorProvider
- solaris：DevPollSelectorProvider
- Linux：EPollSelectorProvider (Linux kernels >= 2.6)或PollSelectorProvider
- windows：WindowsSelectorProvider

所以不需要特别指定，Oracle JDK**会自动选择合适的Selector**。如果想设置特定的Selector，可以设置属性，例如： -Djava.nio.channels.spi.SelectorProvider=sun.nio.ch.EPollSelectorProvider。

JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，所以Netty自4.0.16起, Netty为Linux通过JNI的方式提供了native socket transport。Netty重新实现了epoll机制。

1. 采用边缘触发方式；
2. netty epoll transport暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；
3. C代码，更少GC，更少synchronized。

### BIO、NIO、AIO有什么区别

**BIO(Blocking I/O)：**同步阻塞I/O模式，**数据的读取写入必须阻塞在一个线程内等待其完成**。在活动连接数不是特别高(小于单机1000)的情况，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。

**NIO(Non-Blocking/New I/O)：**同步非阻塞I/O模型，NIO提供了与传统的BIO模型中的Socket和ServerSocket 相对应的SocketChannel和ServerSocketChannel两种不同的套接字(用程序通过网络协议进行通信的接口)通道实现。这两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的应用，应使用NIO的非阻塞模式来开发。

- IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。
- 还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

- IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 

**AIO(Asynchronous I/O)：**AIO也就是NIO 2。在Java 7中引入了NIO的改进版NIO2，它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。

### 介绍一下Java的序列化与反序列化

序列化机制可以将**对象转换成字节序列**，**这些字节序列可以保存在磁盘上，也可以在网络中传输**，并允许**程序将这些字节序列再次恢复成原来的对象**。其中，**对象的序列化（Serialize），是指将一个Java对象写入IO流中，对象的反序列化（Deserialize），则是指从IO流中恢复该Java对象。**

若对象要支持序列化机制，则它的类需要**实现Serializable接口**，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。

若要实现序列化，则需要使用对象流**ObjectInputStream**和**ObjectOutputStream**。其中，在序列化时需要调用**ObjectOutputStream**对象的**writeObject()**方法，以输出对象序列。在反序列化时需要调用**ObjectInputStream**对象的**readObject()**方法，将对象序列恢复为对象。

### **Java序列化中如果有些字段不想进行序列化，怎么办**

**序列化**：讲java对象转换为二进制流写入磁盘，叫做序列化

**为什么要序列化？**

Java中对象的序列化指的是**将对象转换成字节序列的形式来表示**，这些字节序列包含了对象的数据和信息，一个序列化的对象写到数据库或者磁盘中，也可用于网络传输，其中我们的实体类实现**Serializable**接口，目的就是为了让其可序列化。

当然，序列化的目标就是为了反序列化，这样才可以把传输过来的二进制转化为本地java对象。

**不想序列化的意义**

如果不想被序列化那么在**变量名前加transient关键字**,其中的作用有两点：

1.为了**数据的安全**，避免序列化和反序列化。在实际开发中，如果一个用户有一些敏感化的词（比如密码和银行卡号等），为了安全起见，不希望在网络操作中被传输，这些信息就需要加上transient关键字，这个字段只会在调用者的内存中，而不会写到磁盘里持久化。

2.**节省存储空间**。类中的字段可以从其他字段导出，比如计算一个矩形的面积，我们只需要长宽就可以了，那么面积就不用被序列化。

## **深拷贝VS浅拷贝**

浅拷贝：对基本数据类型进行**值传递**，对引用数据类型进行**地址拷贝**。

深拷贝：对基本数据类型进行**值传递**，对引用数据类型，**创建一个新的对象，并复制其内容**。

## 动态链接和静态链接

在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，

**静态链接**

由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件

以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。

![img](https://img-blog.csdn.net/20180505235327609)

从上面的图中可以看到静态运行库里面的一个目标文件只包含一个函数，如libc.a里面的printf.o只有printf()函数，strlen.o里面只有strlen()函数。

链接器在链接静态链接库的时候是**以目标文件为单位**的。比如我们**引用了静态库中的printf()函数**，那么链接器就**会把库中包含printf()函数的那个目标文件链接进来**，**如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中**。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。

静态链接的缺点很明显，

​		一是**浪费空间**，因为**每个可执行程序中对所有需要的目标文件都要有一份副本**，所以如果**多个程序对同一个目标文件都有依赖**，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以**同一个目标文件都在内存存在多个副本**；

​		另一方面就是**更新比较困难**，因为每当**库函数的代码修改**了，这个时候就需要**重新进行编译链接形成可执行程序**。

但是静态链接的优点就是，在**可执行程序中已经具备了所有执行程序所需要的任何东西**，在执行的时候**运行速度快**。

**动态链接**

为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。

**动态链接的原理**

把**程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序**，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：

假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中**已经存在的lib.o映射到program2的虚拟地址空间**中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库**不会像静态链接那样在内存中存在多分，副本**，而是这**多个程序在执行时共享同一份副本**；另一个优点是，**更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍**。当**程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来**，程序就完成了升级的目标。

但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以**每次执行程序都需要进行链接**，所以**性能会有一定损失**。

**动态链接地址是如何重定位的呢？**
        前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在**形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。**

## 开发环境(IDE),怎么输出字符串“test”

1. 新建文件.java

![img](https://img-blog.csdnimg.cn/20210424141506748.png)

2. javac 将.java文件编译成字节码.class文件

![image-20220406212538310](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220406212538310.png)

3. java Test 执行字节码文件，命令台输出test

![img](https://img-blog.csdnimg.cn/20210424141513198.png)

​                 

## **说一下反射机制**

程序在**运行中动态获取类的属性以及调用它的方法的功能**

通过反射机制，我们可以实现如下的操作：

- 程序运行时，可以通过反射获得任意一个**类的Class对象**，并通过这个对象查看这个类的信息；
- 程序运行时，可以通过反射创建任意一个**类的实例**，并访问该实例的成员；
- 程序运行时，可以通过反射机制生成一个**类的动态代理类**或动态代理对象。

原理：通过将**类对应的字节码文件加载到jvm内存中**得到一个Class对象，通过这个Class对象可以反向获取实例的各个属性以及调用它的方法。

通过3种方式获得Class

![img](https://img-blog.csdnimg.cn/20210424141517817.png)

Stu.class

stu.getClass()

Class.forName(Stu);

获得了Class后，我们就可以调用Class对象的newInstance()方法来创建Class对象对应类的实例了；或者通过获得构造器(类一定要有空参构造)，给构造器传入参数，也可创建实例。

![img](https://img-blog.csdnimg.cn/20210424141525906.png)

使用场景：

1. 通过反射**配置文件**并得到相应信息

- 加载配置文件，并解析配置文件得到相应信息
- 根据解析的字符串利用反射机制获取某个类的Class实例
- 动态配置属性

2. JDK**动态代理**
3. jdbc通过**Class.forName()加载数据的驱动程序**
4. Spring**解析xml装配Bean**
5. 面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。

## object的方法有哪些？notify和notifyAll的区别？

1.  **getClass**   final方法，获取运行时类型
2.  **toString**     对象的字符串表达形式（对象所属类的名称+@+转换为十六进制的对象的哈希值组成的字符串）
3.  **equals**      如果没有重写用的就是Object里的方法，和==一样都是比较两个引用地址是否相等，或者比较基本数据类型值是否相等
4.  **Clone**        保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常
5.  **notify**        唤醒在该对象上等待的某个线程
6.  **notifyAll**     唤醒在该对象上等待的所有线程
7.  **wait**            wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁，知道其他线程调用此方法的notify()方法或者notifyAll()   方法，当前线程被唤醒（进入就绪状态），还有一个wait(long timeout)超时时间-补充sleep不会释放锁
8.  **Finalize**()    可以用于对象的自我拯救
9.  **Hashcode**  用于哈希查找，可以**减少在查找过程中使用equals的次数**，重写了equals方法一般要重写hashCode方法，这个方法在一些具有哈希功能的Collection中用到，equals相等hashcode必相等，hashcode相等equals不一定相等。



## **数组与链表的区别**

数组：在内存中，数组是一块连续的区域，随机查找快。插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要往后移动。删除数据时，这个数据后面的数据都要往前移动。

链表：在内存中可以存在任何地方，不要求连续。增加数据和删除数据很容易，直接将尾指针指向新加的节点，删除数据的话，把尾指针指向下一个节点即可。但是查询的时候，需要从头结点一个一个查询下去！


## **static关键字**

**Static方法**

在静态方法中，我们可以直接类名.方法名()即可调用，要注意的是，静态方法中是不可访问非静态变量和方法的。

**Static变量**

静态变量是被所有的对象共享，在**内存中只有一个副本**(存在**方法区**)，只能在**类初次加载的时候才会被初始化。**

**Static代码块**

**只需要执行一次的初始化操作**都放在static代码块中进行，为了优化程序性能。比如判断年龄区间，有一个开始年龄和结束年龄，我不会每次都用Date类去生成，

固定好了区间，直接初始化一次即可。

**静态内部类**

静态内部类是指使用 static 修饰的内部类。

```java
public class Outer {
    static class Inner {
        // 静态内部类
    }
}
```

1. 在**创建**静态内部类的**实例**时，**不需要创建外部类的实例**。

```java
public class Outer {
    static class Inner {
    }
}
class OtherClass {
    Outer.Inner oi = new Outer.Inner();
}
```

2) 静态内部类中可以定义静态成员和实例成员。外部类以外的其他类需要通过**完整的类名访问**静态内部类中的**静态成员**，如果要访问静态内部类中的**实例成员**，则需要**通过静态内部类的实例**。

```java
public class Outer {
    static class Inner {
        int a = 0;    // 实例变量a
        static int b = 0;    // 静态变量 b
    }
}
class OtherClass {
    Outer.Inner oi = new Outer.Inner();
    int a2 = oi.a;    // 访问实例成员
    int b2 = Outer.Inner.b;    // 访问静态成员
}
```

3. 静态内部类可以直接访问外部类的静态成员，如果要访问外部类的实例成员，则需要通过外部类的实例去访问。

```java
public class Outer {
    int a = 0;    // 实例变量
    static int b = 0;    // 静态变量
    static class Inner {
        Outer o = new Outer;
        int a2 = o.a;    // 访问实例变量
        int b2 = b;    // 访问静态变量
    }
}
```

## **Stream关键字**

## java8新特性

1. Lambda新特性

函数作为参数传递进方法中

**作用**：

- 代替实现接口时写匿名内部类繁琐代码
- 使代码变得更加简洁紧凑

**写法**：

- 无参数，无返回 
  - () -> System.out.println("");
- 有参数，无返回
  - (x) -> System.out.println(x);
- 无参数，返回
  - () -> 5;
- 有参数，返回
  - (x, y) -> x - y;
  - (x) -> 2 * x;

**注：**

1. 可选类型声明：**不需要声明参数类型，**编译器可以统一识别参数值
2. 可选的参数圆括号：一个参数无需定义圆括号，多个参数需要定义圆括号
3. 可选的大括号：如果主体包含了一个语句，就不需要大括号
4. 可选的返回关键字：如果主体只有一个表达式返回值，大括号需要指定表达式返回了一个数值



2. 默认方法

​		接口中默认方法，可以有方法体

3. 方法引用
4. Stream API

- stream流
  - filter（过滤）
  - sort（排序）
  - map（对某个对象映射）
  - limit（获取指定数量的流）

``` java
List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
numbers.stream().filter(t -> t % 2 == 0).map(t -> String.valueOf(t) + "*").collect(Collectors.toList()).forEach(System.out::println);
IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();
```

# Java集合

## Java中有哪些容器（集合类）？

Java中的集合类主要由**Collection和Map**这两个接口派生而出，其中**Collection接口又派生出三个子接口**，分别是**Set、List、Queue**。所有的Java集合类，都是Set、List、Queue、Map这四个接口的实现类，这四个接口将集合分成了四大类，其中

- **Set**代表**无序的，元素不可重复**的集合；
- **List**代表**有序的，元素可以重复**的集合；
- **Queue**代表**先进先出（FIFO）**的队列；
- **Map**代表具有**映射关系（key-value）**的集合。

这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。

Collection体系的继承树：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688819081/74C2C3389688C6364FF2DE8AA768A039)

Map体系的继承树：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688841352/E26BABF74692B006DA33C112A6FD5EEC)

## Java中的容器，线程安全和线程不安全的分别有哪些？

java.util包下的集合类大部分都是线程不安全的，例如我们常用的HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap，这些都是线程不安全的集合类，但是它们的优点是性能好。如果需要使用线程安全的集合类，则可以使用Collections工具类提供的synchronizedXxx()方法，将这些集合类包装成线程安全的集合类。

java.util包下也有线程安全的集合类，例如**Vector、Hashtable**。这些集合类都是比较古老的API，虽然实现了线程安全，但是性能很差。所以即便是需要使用线程安全的集合类，也建议将线程不安全的集合类包装成线程安全集合类的方式，而不是直接使用这些古老的API。

从Java5开始，Java在java.util.**concurrent包**下**提供了大量支持高效并发访问的集合类**，它们既能包装良好的访问性能，又能包装线程安全。这些集合类可以分为两部分，它们的特征如下：

- 以**Concurrent**开头的集合类：

  以**Concurrent**开头的集合类代表了支持并发访问的集合，它们可以**支持多个线程并发写入访问**，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以Concurrent开头的集合类采用了更复杂的算法来保证**永远不会锁住整个集合**，因此在并发写入时有较好的性能。

- 以**CopyOnWrite**开头的集合类：

  以**CopyOnWrite**开头的集合类采用**复制底层数组**的方式来**实现写操作**。当线程对此类集合执行读取操作时，线程将会**直接读取集合本身**，无须加锁与阻塞。当线程对此类集合**执行写入操作**时，集合会**在底层复制一份新的数组**，接下来**对新的数组执行写入操作**。由于**对集合的写入操作都是对数组的副本执行操作**，因此它是线程安全的。

java.util.concurrent包下线程安全的集合类的体系结构：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688877249/53AA859E1B3A9CD7709DF9366999B88D)

## Map接口有哪些实现类？

Map接口有很多实现类，其中比较常用的有**HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap**。

对于不需要排序的场景，优先考虑使用**HashMap**，因为它是性能最好的Map实现。如果需要保证线程安全，则可以使用**ConcurrentHashMap**。它的性能好于Hashtable，因为它在**put时**采用**分段锁/CAS**的加锁机制，而不是像Hashtable那样，无论是put还是get都做同步处理。

对于需要排序的场景，如果需要按**插入顺序排序**则可以使用**LinkedHashMap**，如果需要将key按**自然顺序**排列甚至是**自定义顺序排列**，则可以选择**TreeMap**。如果需要保证线程安全，则可以使用Collections工具类将上述实现类包装成线程安全的Map。



## List、Set、Map三者的区别

**List**：存储的元素是**有序的、可重复的**

**Set**：存储的元素是**无序的、不可重复的**

**Map**：使用**键值对(key-Value)存储**，里面key-value映射的规则是**Hash函数映射**，**一个key只能映射到一个Value**

## ArrayList与LinkedList的区别

1. **是否保证线程安全**：[ArrayList](https://so.csdn.net/so/search?q=ArrayList&spm=1001.2101.3001.7020)和LinkedList都是不同步的，也就是不保证线程安全；

2. **底层数据结构**：ArrayList使用的是**数组**，[LinkedList](https://so.csdn.net/so/search?q=LinkedList&spm=1001.2101.3001.7020)使用的是**双向链表**

3. **插入和删除**是否受元素位置的影响：
   - ArrayList采用数组储存，n4插入和删除元素的时间复杂度受元素位置的影响。会将目标元素的后面所有元素进行移动。													            
   - LinkedList采用链表存储，插入和删除操作不受元素位置的影响。直接断开链表进行插入与删除，不必大规模操作元素。
4. 是否支持**快速随机访问**：LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。

5. **内存空间占用**：ArrayList的空间浪费主要体现在**list列表的结尾会预留一定的容量空间**，而LinkedList的空间花费则体现在它的**每一个元素**都需要消耗比ArrayList更多的空间(因为一个节点(双链表)**要放前指针、值、后指针**)。

6. 数组查找原理：**数组空间连续**，查询通过**偏移量查找O(1)**，linkedlist底层是**链表**，通过**指针访问查询O(n)**

## ArrayList与Vector区别？为什么要用ArrayList取代Vector

底层都是**Object[]数组**

Vector是[线程安全](https://so.csdn.net/so/search?q=线程安全&spm=1001.2101.3001.7020)的，就是说某一个时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。但是**实现同步**需要**很高的花费**，因此，**ArrayList性能更好**。

扩容：Vector每次**扩为2倍**，ArrayList为**1.5倍**

**默认长度都是10**

## 有哪些线程安全的List？

1. **Vector**

   Vector是比较古老的API，虽然保证了线程安全，但是由于效率低一般不建议使用。

2. **Collections.SynchronizedList**

   SynchronizedList是Collections的内部类，Collections提供了synchronizedList方法，可以将一个线程不安全的List包装成线程安全的List，即SynchronizedList。它比Vector有更好的扩展性和兼容性，但是它所有的方法都带有同步锁，也不是性能最优的List。

3. **CopyOnWriteArrayList**

   CopyOnWriteArrayList是Java 1.5在java.util.concurrent包下增加的类，它采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。在所有线程安全的List中，它是性能最优的方案。

## 介绍一下ArrayList的数据结构？

ArrayList的底层是用**数组**来实现的，默认**第一次**插入元素时创建**大小为10**的数组，超出限制时会**增加50%**的**容量**，并且数据以 **System.arraycopy()** 复制到新的数组，因此最好能给出数组大小的预估值。

按数组下标**访问元素**的**性能很高**，这是数组的基本优势。直接在**数组末尾加入元素的性能也高**，但如果**按下标插入、删除元素**，则要用 **System.arraycopy() 来移动部分受影响的元素**，**性能**就变**差**了，这是基本劣势。

## 谈谈CopyOnWriteArrayList的原理

CopyOnWriteArrayList是Java并发包里提供的并发类，简单来说它就是一个**线程安全且读操作无锁**的**ArrayList**。正如其名字一样，在**写操作时会复制一份新的List**，在**新的List上完成写操**作，然后再将**原引用指向新的List**。这样就保证了写操作的线程安全。

在**上锁执行写操作**的过程中，如果**有需要读操作，会作用在原容器**上。因此**上锁的写操作不会影响到并发访问的读操作**。

- 优点：**读操作性能很高**，因为**无需任何同步措施**，比较适用于**读多写少的并发场景**。在遍历**传统的List**时，若**中途有别的线程对其进行修改**，则会**抛出ConcurrentModificationException异常**。而CopyOnWriteArrayList由于其"读写分离"的思想，**遍历和修改操作分别作用在不同的List容器**，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。
- 缺点：一是**内存占用问题**，毕竟每次执行**写操作都要将原容器拷贝一份**，**数据量大时，对内存压力较大**，可能会引起频繁GC。二是**无法保证实时性**，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在**写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。**

## 说一说TreeSet和HashSet的区别

HashSet、TreeSet中的元素**都是不能重复的**，并且它们都是**线程不安全**的，二者的区别是：

1. **HashSet**中的**元素可以是null**，但**TreeSet**中的元素**不能是null**；
2. **HashSet不能保证**元素的**排列顺序**，而**TreeSet支持自然排序、定制排序**两种排序的方式；
3. HashSet底层是采用**哈希表**实现的，而TreeSet底层是采用**红黑树**实现的。

## 说一说HashSet的底层结构

HashSet是基于**HashMap**实现的，**默认构造函数**是**构建一个初始容量为16**，**负载因子为0.75** 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 **HashMap 的 key** 来保存，而 HashMap 的 **value** 则存储了一个 **PRESENT**，它是一个静态的 Object 对象。

## BlockingQueue中有哪些方法，为什么这样设计？

为了应对不同的业务场景，BlockingQueue 提供了4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每组方法的表现是不同的。这些方法如下：

|      |  抛异常   |  特定值  |  阻塞  |         超时         |
| :--: | :-------: | :------: | :----: | :------------------: |
| 插入 |  add(e)   | offer(e) | put(e) | offer(e, time, unit) |
| 移除 | remove()  |  poll()  | take() |   poll(time, unit)   |
| 检查 | element() |  peek()  |        |                      |

四组不同的行为方式含义如下：

- 抛异常：如果操作无法立即执行，则抛一个**异常**；
- 特定值：如果操作无法立即执行，则返回一个**特定的值**(一般是 true / false)。
- 阻塞：如果操作无法立即执行，则该方法调用将会发生**阻塞**，直到能够执行；
- 超时：如果操作无法立即执行，则该方法调用将会发生**阻塞**，直到能够执行。但**等待时间**不会超过给定值，并**返回一个特定值**以告知该操作是否成功(典型的是true / false)。

## BlockingQueue是怎么实现的？

**BlockingQueue是一个接口**，它的实现类有**ArrayBlockingQueue**、**DelayQueue**、 **LinkedBlockingQueue**、**PriorityBlockingQueue**、**SynchronousQueue**等。它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于put与take操作的原理是类似的。下面以ArrayBlockingQueue为例，来说明BlockingQueue的实现原理。

首先看一下**ArrayBlockingQueue的构造函数**，它**初始化**了put和take函数中用到的关键成员变量，这两个变量的类型分别是**ReentrantLock**和**Condition**。ReentrantLock是AbstractQueuedSynchronizer（AQS）的子类，它的newCondition函数返回的Condition实例，是定义在AQS类内部的ConditionObject类，该类可以直接调用AQS相关的函数。

```java
public ArrayBlockingQueue(int capacity, boolean fair) {
	if (capacity <= 0)          
		throw new IllegalArgumentException();      
	this.items = new Object[capacity];      
	lock = new ReentrantLock(fair);      
	notEmpty = lock.newCondition();      
	notFull = lock.newCondition();  
}
```

**put函数**会在**队列末尾添加元素**，如果**队列已经满**了，无法添加元素的话，就**一直阻塞等待到可以加入为止**。函数的源码如下所示。我们会发现put函数使用了wait/notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用ReentrantLock和Condition相结合的机制，即先获得锁，再等待，而不是synchronized和wait的机制。

```java
public void put(E e) throws InterruptedException {
	checkNotNull(e);      
	final ReentrantLock lock = this.lock;      
	lock.lockInterruptibly();      
	try {          
		while (count == items.length)              
			notFull.await();          
		enqueue(e);      
		}
	finally 
		{          
		lock.unlock();      
		}  
}
```

再来看一下消费者调用的**take函数**，take函数在**队列为空时会被阻塞**，一直到**阻塞队列加入了新的元素**。

```java
public E take() throws InterruptedException {      
	final ReentrantLock lock = this.lock;      
	lock.lockInterruptibly();      
	try {          
		while (count == 0)              
			notEmpty.await();          
		return dequeue();      
		} 
	finally {          
		lock.unlock();      
	}  
}
```

await操作：

我们发现ArrayBlockingQueue并没有使用Object.wait，而是使用的Condition.await，这是为什么呢？Condition对象可以提供和**Object的wait和notify**一样的行为，但是**后者必须先获取synchronized这个内置的monitor锁才能调用**，而**Condition则必须先获取ReentrantLock**。这两种方式在阻塞等待时都会将相应的锁释放掉，但是**Condition的等待可以中断**，这是二者唯一的区别。

我们先来看一下Condition的await函数，await函数的流程大致如下图所示。await函数主要有三个步骤，一是调用addConditionWaiter函数，在**condition wait queue队列中添加一个节点**，**代表当前线程在等待一个消息**。然后调用**fullyRelease函数**，将**持有的锁释放掉**，调用的是AQS的函数。最后一直调用**isOnSyncQueue函数判断节点是否被转移到sync queue队列**上，也就是**AQS中等待获取锁的队列**。如果**没有**，则进入**阻塞状态**，如果已经**在队列**上，则调用acquireQueued函数**重新获取锁**。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/37DE256DECC211F4D5230BF7A654E128.png)

signal操作：

signal函数将**condition wait queue队列中队首的线程节点转移等待获取锁的sync queue队列中**。这样的话，await函数中调用**isOnSyncQueue**函数就会**返回true**，导致**await函数进入最后一步重新获取锁**的状态。

我们这里来详细解析一下condition wait queue和sync queue两个队列的设计原理。**condition wait queue是等待消息的队列**，因为**阻塞队列为空而进入阻塞状态的take函数操作就是在等待阻塞队列不为空的消息**。而**sync queue队列则是等待获取锁的队列**，take函数获得了消息，就可以运行了，但是它还必须**等待获取锁**之后才能真正**进行运行状态**。

signal函数其实就做了一件事情，就是不断尝试调用transferForSignal函数，将condition wait queue队首的一个节点转移到sync queue队列中，直到转移成功。因为一次转移成功，就代表这个消息被成功通知到了等待消息的节点。

signal函数的示意图如下所示。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/61A52D5795794D763D6F8D37D13AFE07.png)

## Stream（不是IOStream）有哪些方法？

Stream提供了大量的方法进行聚集操作，这些方法既可以是“中间的”，也可以是“末端的”。

- **中间方法**：中间操作允许流保持打开状态，并允许直接调用后续方法。中间方法的返回值是另外一个流。
- **末端方法**：末端方法是对流的最终操作。当对某个Stream执行末端方法后，该流将会被“消耗”且不再可用。

除此之外，关于流的方法还有如下两个特征：

- **有状态的方法**：这种方法会给流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素以排序的方式被处理等。有状态的方法往往需要更大的性能开销。
- **短路方法**：短路方法可以尽早结束对流的操作，不必检查所有的元素。

下面简单介绍一下Stream常用的中间方法：

- filter(Predicate predicate)：过滤Stream中所有不符合predicate的元素。
- mapToXxx(ToXxxFunction mapper)：使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。
- peek(Consumer action)：依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元素。该方法主要用于调试。
- distinct()：该方法用于排序流中所有重复的元素（判断元素重复的标准是使用equals()比较返回true）。这是一个有状态的方法。
- sorted()：该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。
- limit(long maxSize)：该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。

下面简单介绍一下Stream常用的末端方法：

- forEach(Consumer action)：遍历流中所有元素，对每个元素执行action。
- toArray()：将流中所有元素转换为一个数组。
- reduce()：该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。
- min()：返回流中所有元素的最小值。
- max()：返回流中所有元素的最大值。
- count()：返回流中所有元素的数量。
- anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合Predicate条件。
- noneMatch(Predicate predicate)：判断流中是否所有元素都不符合Predicate条件。
- findFirst()：返回流中的第一个元素。
- findAny()：返回流中的任意一个元素。



## ArrayList的扩容机制

1. 首先空构造初始化，指向一个空数组
2. add方法(扩容的触发是添加)

![img](https://img-blog.csdnimg.cn/20210221192142458.png)

​		第一次调用，会与默认值(10)比较，看谁大选谁

![img](https://img-blog.csdnimg.cn/20210221192201970.png)

​		然后进行判断是否需要扩容

![img](https://img-blog.csdnimg.cn/20210221192243109.png)

​		进入扩容函数

![img](https://img-blog.csdnimg.cn/20210221192302281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

​		**扩容后的数量是扩容前的1.5倍**

![img](https://img-blog.csdnimg.cn/20210221192317279.png)

​		这个是因为第一次的时候**oldCapacity=0**，所以**newCapacity=0**，所以这样**才会小于0**

​		然后**把之前默认值(10)直接赋值给新容量**

​		规定最大的最大值，要-8(虚拟机的限制);

![image-20220528211159746](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220528211159746.png)

​		不能超过规定长度

![img](https://img-blog.csdnimg.cn/20210221192401825.png)

​		然后**将老数组的数组复制过去**

**总结**：

1. 构造方法：初始化一个空数组

2. add方法：1.扩容逻辑 2.赋值 3.返回true

   扩容逻辑：① 第一次直接初始化长度为10的数组

​        	        	   ② 后续按照**1.5倍扩容**(满足扩容条件)**传入的长度(Mincapacity)大于了现有数组长度**(elementData.length)。

**扩容操作**需要**Arrays.copyOf()将原数组整个复制到新数组**，操作**代价很高**，因此最好在**创建的时候就指定大概的容量大小**，**减少扩容次数**。

## Comparable和Comparator的区别

如果在**定义类时**，就**实现了Comparable接口**，直接在里面**重写compareTo()方法**，

如果没实现，在**业务开发中需要比较排序**的功能，就在单独**写一个类实现Comparator接口**，在里面**重写compare()方法**，这个类需要作为参数传入到工具类Collections.sort()和Arrays.sort()方法中，

主要区别是一个**一开始就实现**，一个**后期实现**。

```java
List<Dog> list= new ArrayList<>();
    list.add(new SortTest().new Dog(5, "DogA"));
    list.add(new SortTest().new Dog(6, "DogB"));
    list.add(new SortTest().new Dog(7, "DogC"));
    Collections.sort(list, new Comparator<Dog>() {
        @Override
        public int compare(Dog o1, Dog o2) {
        return o2.age - o1.age;
        }
    });
    System.out.println("给狗狗按照年龄倒序："+list);
```

## Iterator

提供遍历任何**Collection**的接口，我们可以**从Collection中使用迭代器方法来获取迭代器实例。**

迭代器 it 的两个基本操作是 **next 、hasNext 和 remove**。

调用 **it.next()** 会返回迭代器的**下一个元素**，并且更新迭代器的状态。

调用 **it.hasNext(**) 用于**检测集合中是否还有元素。**

调用 **it.remove()** 将迭代器**返回的元素删除**。

```java
// 引入 ArrayList 和 Iterator 类
import java.util.ArrayList;
import java.util.Iterator;

public class RunoobTest {
    public static void main(String[] args) {

        // 创建集合
        ArrayList<String> sites = new ArrayList<String>();
        sites.add("Google");
        sites.add("Runoob");
        sites.add("Taobao");
        sites.add("Zhihu");

        // 获取迭代器
        Iterator<String> it = sites.iterator();

        // 输出集合中的所有元素
        while(it.hasNext()) {
            System.out.println(it.next());
        }
        
        while(it.hasNext()) {
            Integer i = it.next();
            if(i < 10) {  
                it.remove();  // 删除小于 10 的元素
            }
        }
    }
}
```

## 当一个集合被作为参数传递给一个函数时，如何确保函数不能修改它

在作为参数传递之前，我们可以使用**Collections.unmodifiableCollection(Collection c)**方法创建一个只读集合，这将确保**改变集合的任何操作**都会**抛出UnsupportedOperationException**

## HashMap是如何解决哈希冲突的？

为了解决碰撞，**哈希冲突发生时**，用**equals比较key值**，如果**相同就覆盖**，如果**不同就插到链表后面**

当链表长度到达一个阈值（数组长度大于64，链表长度大于8）时，会将**链表转换成红黑树**提高性能。而当链表长度缩小到另一个阈值时，又会将红黑树转换回单向链表提高性能。

## Enumeration和Iterator接口的区别

**Enumeration是iterator的两倍，也使用更少的内存**。Enumeration是非常基础的，也满足了基础的需要。但是与Enumeration相比，**iteration更加安全**，因为当**一个集合正在被遍历的时候，它会阻止其他线程去修改集合。**

迭代器取代了java集合框架中的Enumeration。迭代器**允许调用者从集合中移除元素**，而Enumeration不能做到，为了使它的功能更加清晰，迭代器方法名已经经过改善。

## HashMap和Hashtable的区别

1. **线程是否安全**：**HashMap**是**非线程安全**的，**HashTable**是**线程安全**的，因为HashTable内部的方法基本都是经过synchronized修饰。

2. **效率**：因为线程安全的问题，**HashMap**要比HashTable**效率高一点**。另外，HashTable基本被淘汰了，不要在代码中使用它。

3. **对Null key**和**Null value**的支持：HashMap**可以存储null的key和value**，但**null作为键只有一个**，**null作为值可以有多个**；HahTable**不允许有null键和null值**，否则会**抛出NullPoninterException**。

4. 初始容量大小和每次扩充容量大小的不同：

   ①创建时如果不指定容量初始值，HashMap默认的**初始化大小为16,**。之后每次**扩充**，**容量变为原来的2倍**。HashTable默认的初始大小为**11**，之后每次扩充，容量变为原来的**2n+1**。

   ②创建**给了初始值**，但是**HashMap会把将其扩充为最接近的2的幂次方大小**（通过几次无符号右移和按位或运算，将1100 1100 1100转换为了1111 1111 1111，再加1，就得到了大于1100 1100 1100的第一个2的幂）。Hahstable就会这个值直接当做容量大小，

5. **底层数据结构**：JDK1.8以后的HashMap在解决哈希冲突有了较大的变化，当链表长度大于8(链表转换为红黑树前会判断，如果当前数据的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树。)时，将链表转化为红黑树，以减少搜索时间。Hashtable没有这样的机制。

## 如果HashMap的大小超过了负载因子（load factor）定义的容量，怎么办

**默认的负载因子为0.75**，当一个**map填满75%**的时候，会**创建原来HashMap大小两倍的数组**，并**将原来的对象放入新的数组**，这个过程叫做**rehashing**，因为他调用hash方法找到新的bucket位置，**只可能在原下标或<原下标+原容量的位置>**。



## 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？

红黑树是为了解决二叉查找树的缺陷，**二叉查找树**在**特殊情况**下会**变成一条线性结构**，**遍历查找会非常慢**，而**红黑树**在**插入新数据后**可能需要通过**左旋**、**右旋**、**变色**等操作来**保持平衡**，引入红黑树就是为了查找数据快，解决链表查询深度的问题。

## HashMap和HashSet区别

HashSet底层是基于HashMap实现的。除了**clone()、writeObject()、readObject()**是**HashSet**自己不得不**实现**之外，其他方法都是直接调用HashMap中的方法。

![img](https://img-blog.csdnimg.cn/20210221192437568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

## **HashSet如何检查重复**

当把对象加入到Set中，会**计算对象的哈希值**，与**Set[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)中的对象哈希值一一比较**，如果**没有相同的哈希值**，说明**无重复**；发现**有相同的哈希值**，然后将该位置上的对象与新加入的对象**用equals比较对象的属性是否真的相等**，如果**相等说明重复不能加入**。

HashCode与equals的相关规定：

- 如果两个对象相等，则hashcode一定也是相同的

- 两个对象相等，对两个euqals方法返回true

- 两个对象有相同的hashcode值，他们也不一定是相等的

  综上，equals()方法被覆盖过，则hashCode()方法也必须被覆盖

- hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode(),则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

**==与equals的区别**

对于基本数据类型来说，==比较的是值是否相等。

对于引用数据类型来说，==比较的是两个引用是否指向同一个对象地址(两者在内存存放的地址(堆内存地址)是否指向同一个地方)

对于引用数据类型(包括包装类型)来说，**equals**如果**没有被重写**，**对比**他们的**地址**是否相等；如果**equals()**方法**被重写**(例如String)，则**比较**的是**内容**。

## hashMap jdk8与jdk7区别

JDK8新增了**红黑树**，JDK8通过**数组+链表+红黑树**来实现。

JDK7使用的插入是**头插法**，JDK8使用**尾插法**。

​		因为JDK7采用**单链表**进行纵向延伸，**采用头插法会容易出现逆序且环形链表死循环问题**。但是在JDK1.8之后因为**加入了红黑树使用尾插法**，能够避免出现逆序且链表死循环的问题。

JDK8中因为使用红黑树保证了插入和查询的效率，所以实际上JDK8中的hash算法复杂度降低了。

JDK7中是**先扩容再添加新元素**，JDK8中是**先添加新元素在扩容**。

JDK8中数组扩容的条件也发生了变化，只会判断**当前元素个数是否超过了阈值**，而不再判断当前put进来的元素对应的数组下标位置是否有值。

## **HashMap的底层实现**

**JDK1.8之前**HashMap底层是**数组和链表**。HashMap**通过key的hashCode经过扰动函数处理过后得到hash值**，然后**通过(n-1)&hash判断当前元素存放的位置(这里的n是指数组的长度)**，如果**当前位置存在元素**的话，就**判断该元素与要存入的元素的hash值以及key是否相同**，如果**相同的话**，**直接覆盖**，**不相同就通过拉链法解决冲突**。拉链法是指**遇到哈希冲突就将冲突的值加到链表中即可**。
![img](https://img-blog.csdnimg.cn/20210221192519962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

JDK1.8以后的HashMap在解决哈希冲突有了较大的变化，当链表长度大于8(链表转换为红黑树前会判断，如果当前数据的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树。)时，将链表转化为红黑树，以减少搜索时间。

![img](https://img-blog.csdnimg.cn/20210221192537711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

## **HashMap的长度为什么是2的幂次方**

1. 为了能**让HashMap存取高效**，**尽量减少碰撞**，也就是**要尽量把数据分配均匀**。
2. Hash值的范围是-2^31~2^31。虽然有这么多，但是计算机的内存没有这么多内存去储存这些数据，所以我们都会把**hash值进行处理**。我们先对**数组的长度取模运算，得到的余数才能用来要存放的位置**。计算方法是**hash& (n-1)(n是数组的长度)**。其中取模运算是**%操作中除数是2的幂次方的话**，可以把**%等价为&(除数-1)**,这样就会加快速度。 这就解释了为什么要用2的幂次方。

2的n次方实际就是1后面n个0，2的n-1次方实际就是n个1，这样按位与时，每一位都&1

**与运算&  1&1=1**

若直接使用key.hashCode()计算出hash值，则范围为：**-2147483648**到**2147483648**，大约40亿的映射空间。若映射得比较均匀，是很难出现碰撞的。但是这么大范围无法放入内存中，况且HashMap的 初始容量为16。所以必须要进行与运算取模。

**HashMap的负载因子为0.75** 

比如当前的容器容量是16，负载因子是**0.75**，**16*0.75=12**，也就是说，当**容量到达12**的时候就会进行**扩容**操作。

当负载因子是**1.0**的时候，意味着只有**当数组的值全部填充**了，才会发生扩容，这就带来了很大的问题，因为hash冲突是避免不了的，当**负载因子是1.0的时候**，意味着会**出现大量的hash冲突**，底层的红黑树变得异常复杂，对于查**询效率极其不利**，这种情况就是**牺牲了时间来保证空间的利用率**。

负载因子是**0.5**的时候，意味着当数组中的**元素达到了一半就开始扩容**，填充的元素少了**hash冲突也会少**，底层的**链表长度或者红黑树的高度就会降低**，**查询效率就会增加**。但是**空间利用率就会大大降低**，原本存储1M的数据，意味着需要2M的空间。

负载因子是**0.75**的时候，**空间利用率比较高**，而且**避免了相当多的Hash冲突**，使得**底层的链表或者红黑是的高度比较低**，**提升了空间效率**。

## HashMap扰动函数

```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

- 为什么要用扰动函数？

答：扰动函数就是**解决碰撞问题**。若不使用扰动函数，则直接将key.hashCode()和下面的步骤2做与运算，则会有以下情景。

以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。

![img](https://img-blog.csdnimg.cn/20190823160942538.png)

这样就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，则碰撞会更严重。

- 扰动函数是怎么实现的？

1. 使用key.hashCode()计算[hash](https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020)值并赋值给变量h；
2. 将**h向右移动16位**；
3. 将**变量h**和**向右移16位的h**做**异或运算**（二进制位**相同为0**，**不同为1**）。

![img](https://img-blog.csdnimg.cn/20190823161846761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyY21k,size_16,color_FFFFFF,t_70)

0 ^ 1 = 1

- 为什么要将key.hashCode()右移16位？

答：右移16位正好为**32bit的一半**，自己的高半区和低半区做异或，是为了混合原始哈希码的高位和低位，来**加大低位的随机性**。而且**混合后的低位掺杂了高位的部分特征**，使高位的信息也被保留下来。

## hashmap的put方法流程

HashMap通过key的hashCode经过扰动函数处理后得到hash值，然后通过(n-1)&hash判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话直接覆盖，不同的话就通过拉链法解决冲突。

- **首先计算hash值**

- 经过**扰动函数**使其hash值更散列（调用key对象的hashcode方法计算出来hash值，将Hash值得高16位右移并与原Hash值取异或运算^,混合高16位和低16位得值，得到一个更加散列得低16位hash值

- 然后进入**putval**方法，会判断是否**第一次调用put**，若是第一次初始化数组长度16

- **插入数据**：

  - 如果当前位置元素为空，则直接插入数据；

  - 如果当前位置元素非空，且key已存在，则直接覆盖其value；

  - 如果当前位置元素非空，且key不存在，则将数据链到链表末端；

  - 若链表长度达到8且数组长度大于64，则将链表转换成红黑树，并将数据插入树中；

    - jdk7 头插法

    - jdk8 尾插法，遍历链表，若有相同的node，替换，否则尾插，然后再判断是否树化（链表长度大于8，且数组长度大于64）

- **再次扩容**

  如果数组中元素个数（size）超过threshold，则再次进行扩容操作。

## hashmap扩容流程

扩容是多线程操作可能会导致链表成环的出现，然后调用get方法会死循环

触发时机：未初始化，第一次put时   大于扩容阈值

**新建2倍大小数组**，根据新数组长度对其**重新hash**，寻址。具体会将**原来数组链表拆为高低位链表**，**低位链表存放扩容后数组下标没变的结点**，**高位链表存放变了的**，然后**将高低位链表插入新数组**。

例如我们从16扩展为32时，具体的变化如下所示：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688931497/B7A9F3ADBA028FE6FDE22C94D566B4F1)

因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688954741/FB03BC4205AD26DC0210B12412AAC145)

因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是**0的话索引没变**，是**1的话索引变成“原索引+oldCap”**。可以看看下图为16扩充为32的resize示意图：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688973970/C2928A93915A4AEF2709862EBAC8515C)

这个设计确实非常的巧妙，既**省去了重新计算hash值的时间**，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。

## **HashMap多线程操作导致死循环问题**（线程不安全）

```java
void resize(int newCapacity)
{
    Entry[] oldTable = table;
    intoldCapacity = oldTable.length;
    ......
    //创建一个新的Hash Table
    Entry[] newTable =new Entry[newCapacity];
    //将Old Hash Table上的数据迁移到New Hash Table上
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

void transfer(Entry[] newTable)
{
    Entry[] src = table;
    intnewCapacity = newTable.length;
    //下面这段代码的意思是：
    //  从OldTable里摘一个元素出来，然后放到NewTable中
    for(intj = 0; j < src.length; j++) {
        Entry<K,V> e = src[j];
        if(e != null) {
            src[j] =null;
            do{
                Entry<K,V> next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }while (e != null);
        }
    }
}
```

### 单线程下的ReHash

用key mod 一下表的大小（也就是数组的长度）。

最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。

接下来的三个步骤是Hash表 resize成4，然后所有的<key,value> 重新rehash的过程

![image-20220416153749074](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220416153749074.png)

### 并发下的Rehash

两个线程同时触发了rehash操作，产生了环形链表，可能就会死循环

1. 假设我们有两个线程。我用红色和浅蓝色标注了一下。

```java
do{
    Entry<K,V> next = e.next;// <--假设线程一执行到这里就被调度挂起了
    inti = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;
}while (e != null);
```

而我们的线程二执行完成了。于是我们有下面的这个样子。

![image-20220416154149427](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220416154149427.png)

注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。

2. 线程一被调度回来执行。

- 先是执行 newTalbe[i] = e;
- 然后是e = next，导致了e指向了key(7)，
- 而下一次循环的next = e.next导致了next指向了key(3)

![image-20220416154412212](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220416154412212.png)

3. 线程一继续执行

把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移

![image-20220416154440745](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220416154440745.png)

4. 环形链接出现

e.next = newTable[i] 导致 key(3).next 指向了 key(7)
注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。

![image-20220416154507674](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220416154507674.png)

当我们的线程一调用到HashTable.get(11)时，悲剧就出现了——Infinite Loop

JDK1.8将节点放到扩容后原有链表的尾部

## 如何得到一个线程安全的Map？（HashMap如何实现线程安全？）

1. 使用**Collections工具类**，将线程不安全的Map**包装成线程安全的Map**；

   在Map被创建的时候用马上用**synchronizedMap方法**来包装一下，从而有效避免

   任何非线程安全的意外操作发生，做法如下：

   ```java
   Map<String,String> unSafeMap = new HashMap<String,String>();
   Map safeMap = Collections.synchronizedMap(unSafeMap);
   ```

   然后**任何操作**都**通过实例对象safeMap来进行**，从而就**不会存在线程冲突**导致程序执行结果有误的情况。

2. 使用java.util.concurrent包下的Map，如**ConcurrentHashMap**；

3. 不建议使用Hashtable，虽然Hashtable是线程安全的，但是性能较差。

## HashMap与ConcurrentHashMap有什么区别？

HashMap是非线程安全的，这意味着不应该在多线程中对这些Map进行修改操作，否则会产生数据不一致的问题，甚至还会因为并发插入元素而导致链表成环，这样在查找时就会发生死循环，影响到整个应用程序。

**Collections工具类可以将一个Map转换成线程安全的实现**，其实也就是通过一个包装类，然后把所有功能都委托给传入的Map，**而包装类是基于synchronized关键字来保证线程安全的**（**Hashtable也是基于synchronized关键字**），底层使用的是互斥锁，**性能与吞吐量比较低**。

**ConcurrentHashMap**的实现细节远没有这么简单，因此**性能也要高上许多**。它**没有使用一个全局锁**来锁住自己，而是采用了减少锁粒度的方法，尽量减少因为竞争锁而导致的阻塞与冲突，而且ConcurrentHashMap的**检索操作是不需要锁的**。

## ConcurrentHashMap和Hashtable的区别

体现线程安全的方式不同。

**Hashtable**：使用**synchronized**来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如**使用put添加元素，另一个线程不能使用Put添加元素，也不能使用get**，竞争越激烈效率越低。

**ConcurrentHashMap**:

​		在**JDK1.7**的时候，主要使用**segement**对整个桶数组进行分割，默认是**16**，每个锁只会锁segement，每个segement不会互相影响，当不同线程访问不同数据段的时候，不会发现锁竞争，进而提高效率。

​		在**JDK1.8**，ConcurrentHashMap采用**Node数组+链表+红黑树**的数据结构实现，并发控制采用**CAS+sychronized**来操作。Node适用于链表，TreeNode适用于红黑树。因为会链表和红黑树转换（8-6,其中数组长度没有达到64就先扩容数组，如果达到了树化）

## 介绍一下ConcurrentHashMap是怎么实现的？

JDK 1.7中的实现：

在 jdk 1.7 中，ConcurrentHashMap 是由 **Segment 数据结构和 HashEntry 数组结构**构成，采取**分段锁**来保证安全性。Segment 是 ReentrantLock 重入锁，在 ConcurrentHashMap 中扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每一个HashEntry都是一个链表，Segment 的结构和 HashMap 类似，是一个**数组和链表结构**。

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645689003626/A064CF0DD49D1B3694548913C28728DB)

JDK 1.8中的实现：

JDK1.8 的实现已经摒弃了 Segment 的概念，而是直接用 **Node 数组+链表+红黑树**的数据结构来实现，**并发控制使用 Synchronized 和 CAS 来操作**，整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645689024609/9C8ABF1CD3475339A49DE3B9E1696FE7)



## ConcurrentHashMap线程安全的具体实现/底层具体实现

**JDK1.7**：分段锁，将数据**分为一段一段存储**，然后给**每一个数据段分配一个锁**。当**一个线程占用了其中一个数据段**，**其他数据段仍然可以被其他线程访问**。

**一个ConcurrentHashMap**包含**一个Segment数组**，**每个Segmeng包含一个HashEntry数组**，**每个HashEntry都是一个链表结构的元素**，对HashEntry中的元素修改时，必须首先获得Segment锁。

**JDK1.8**：采用**CAS和synchronized**来保证并发安全。数据结构与HashMap的数据结构相似，都是**数组+链表/红黑树**结构。在**链表长度超过8并且数组长度大于64**时，将链表（寻址时间复杂度O(n)）转化为红黑树（寻址时间复杂度O(log(n)）。

**synchronized只锁定链表或红黑树的首节点**，这时候**只要hash不冲突，就不会产生并发**，效率提升N倍。

## ConcurrentHashMap是怎么分段分组的？

get操作：

Segment的get操作实现非常简单和高效，先经过一次再**散列**，然后使用这个散列值通过散列运算**定位到 Segment**，再通过**散列**算法**定位到元素**。get操作的高效之处在于**整个get过程都不需要加锁**，除非**读到空的值才会加锁重读**。原因就是将使用的**共享变量定义成 volatile 类型**。

put操作：

当执行put操作时，会经历两个步骤：

1. 判断是否需要扩容；
2. 定位到添加元素的位置，将其放入 HashEntry 数组中。

插入过程会进行**第一次 key 的 hash** 来**定位 Segment** 的位置，如果该 **Segment 还没有初始化**，即**通过 CAS 操作进行赋值**，然后进行**第二次 hash** 操作，找到相应的 **HashEntry 的位置**，这里会利用继承过来的锁的特性，在**将数据插入指定的 HashEntry 位置时**（尾插法），会通过继承 ReentrantLock 的 **tryLock()** 方法**尝试去获取锁**，如果获取**成功**就直接**插入相应的位置**，如果已经**有线程获取该Segment的锁**，那当前线程会以**自旋**的方式去继续的调用 **tryLock() 方法去获取锁**，超过**指定次数就挂起，等待唤醒。**

## 说一说你对LinkedHashMap的理解

LinkedHashMap使用**双向链表**来维护key-value对的顺序（其实只需要**考虑key的顺序**），该链表负责维护Map的迭代顺序，**迭代顺序与key-value对的插入顺序保持一致**。

LinkedHashMap可以避免对HashMap、Hashtable里的key-value对进行排序（只要插入key-value对时保持顺序即可），同时又可避免使用TreeMap所增加的成本。

LinkedHashMap需要维护元素的插入顺序，因此**性能略低于HashMap的性能**。但因为它**以链表来维护内部顺序**，所以在**迭代访问Map里的全部元素时将有较好的性能**。

## 请介绍LinkedHashMap的底层原理

LinkedHashMap**继承于HashMap**，它在HashMap的基础上，通过**维护一条双向链表**，解决了HashMap不能随时**保持遍历顺序和插入顺序一致**的问题。在实现上，LinkedHashMap很多方法直接继承自HashMap，仅为维护双向链表重写了部分方法。

如下图，绿色的箭头表示前驱引用，黄色箭头表示后继引用。每当有**新的键值对节点插入**时，新节点最终会**接在tail引用指向的节点后面**。而tail引用则会移动到新的节点上，这样一个双向链表就建立起来了。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/249993-20161215143120620-1544337380.png)

![img](C:/Users/chm/Desktop/Java学习/面经.assets/249993-20161215143544401-1850524627.jpg)

## TreeMap

TreeMap是基于**红黑树**的一种**提供顺序访问的Map**，默认**按键的升序排列**，具体**可按指定的comparator决定**，TreeMap**键、值都不能为null**，hashtable也不能为null

TreeMap的基本操作**containsKey**、**get**、**put**、**remove**方法，它的时间复杂度是**log(N)**。

TreeMap包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。它是Entry类型，Entry是红黑树的节点，它包含了红黑树的6个基本组成：**key、value、left、right、parent和color**。Entry节点根据Key排序，包含的内容是value。Entry中key比较大小是根据比较器comparator来进行判断的。size是红黑树的节点个数。

## Map和Set有什么区别？

Set代表**无序的，元素不可重复**的集合；

Map代表具有**映射关系（key-value）的集合**，其所有的**key是一个Set集合，即key无序且不能重复**。

## List和Set有什么区别？

Set代表**无序的，元素不可重复**的集合；

List代表**有序的，元素可以重复**的集合。

## 红黑树

属于**二叉搜索树**的一种，增删改查o(logn)，可能出现线性化o(n)

性质：

1. 每个节点要么是**红色**，要么是**黑色**。
2. 根节点是**黑色**
3. 每个**叶子节点（空节点）**是**黑色**
4. 每个**红色节点**的**两个子节点**一定是**黑色**，**不能有两个红色节点相连**。
5. 任意**节点到每个叶子节点的路径**都**包含数量相同的黑节点**，俗称：黑高

​		可以推出只要有了一个黑儿子，那么肯定是有两个黑儿子。因为到每个叶子节点上的路径黑节点一样。

6. 如果**一个节点存在黑子节点**，那么**该节点一定有两个子节点**

其中红黑树虽然不是完美的二叉平衡树，但是黑色节点的层数是一样的。所以称为**黑色完全平衡**。

红黑树自平衡靠三种操作：**左旋，右旋，变色**。

左旋右上(右儿子上位)，右旋左上(左儿子上位)

左旋：右儿子当祖先，右儿子的左儿子变为以前祖先的右儿子

![img](https://img-blog.csdnimg.cn/20210221193244659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

右旋：左儿子变成祖先，左儿子的右儿子变成原来祖先的左儿子

![img](https://img-blog.csdnimg.cn/20210221193301127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

变色：红色变黑色或者黑色变红色。

红黑树查找(自平衡)：

![img](https://img-blog.csdnimg.cn/20210221193321214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

红黑树的插入：①**查找插入的位置** ②**插入后自平衡**   新插入节点必须是红色的，**红插**

红黑树插入情景(红插)：

情景1：红黑树为空树

处理：直接把插入节点作为根节点，然后再染成黑色

情景2：插入节点的Key已存在

处理：更新当前节点的值为插入节点的值

情景3：如果插入元素的爸爸是黑色的， 

处理：那么直接插入，没有破坏性质。无需做自平衡。

![img](https://img-blog.csdnimg.cn/2021022119340579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210221193416871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

情景4：如果插入元素的爸爸是红色，会打破  一红(一红两黑)原则

类型是看它是爷爷的什么节点（左左）

![image-20220512144507900](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220512144507900.png)

## HashMap为什么用红黑树而不用B树？

**B/B+树多用于外存上**时，B/B+也被成为一个磁盘友好的数据结构。

HashMap本来是**数组+链表**的形式，**链表**由于其**查找慢**的特点，所以需要被**查找效率更高的树结构来替换**。如果**用B/B+树**的话，在**数据量不是很多的情况**下，**数据都会“挤在”一个结点里面**，这个时候**遍历效率就退化成了链表**。