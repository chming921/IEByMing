# 多线程

## **线程和进程**

**进程：**程序的一次执行，是程序运行的基本单位，进程是动态的，系统运行一个程序是一个进程从创建、运行到消亡的过程。

​			在java中，我们启动main函数就相当于启动了一个JVM的线程，Main函数所在的线程就是整个进程中的一个线程，也称为主线程。

**线程：**线程是比进程更小的执行单位。一个进程在执行过程中会产生多个线程。与进程不同的是同类的多个线程共享**进程的堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**本地方法栈**、**虚拟机栈**。所以系统在产生一个线程，或是各个线程之间切换时，负担比进程小得多，正因为如此，线程也被称为轻量级进程。

![img](https://img-blog.csdnimg.cn/2021032320313728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

在一个JVM进程中，有五块内容：堆，方法区，程序计数器，本地方法栈，虚拟机栈。其中一个JVM进程中包含着多个线程。其中程序计数器、本地方法栈、虚拟机栈是单个线程私有的。堆和方法区是公有区域。

每当运行一个Java程序的时候，就会启动一个JVM进程。不同程序的JVM进程是互不干扰的。每个JVM进程中的线程可以共享该进程中的堆和方法区内存。因此，进程和线程最大的区别在于，进程互不干扰，同一个进程中的线程极有可能互相影响。所以线程开销小(有共享内存区)，但不利于资源的管理和保护；进程则相反。

**程序计数器为什么是私有的？**

程序计数器的作用：

1. 指示程序运行的标志，字节解释器通过程序计数器来一次读取程序命令，从而实现代码的流程控制。

2. 在多线程下，保存当前线程的状态，因为当某个线程运作的时候，可能时间片用完了，程序计数器就保留了运行到了某行，下次到了该线程的时候直接从这个行开始执行程序。

所以需要线程私有，否则无法保存当前线程状态的。

**为什么虚拟机栈和本地方法栈是私有的？**

**虚拟机栈**：每个Java方法被执行的时候都会创建一个**栈帧**，里面包括局部变量表、操作数栈、常量池引用。从**方法调用到完成的过程，对应着栈帧在虚拟机栈中的入栈和出栈过程。**

这里的所有操作都会经过操作数栈，方法栈帧里的操作**全在操作数栈里完成**。所有值压入操作数栈，然后通过操作数栈出栈保存到局部变量表。然后要取的话也是从局部变量表中取出到操作数栈，然后弹出后CPU去计算，计算完成后，然后把结果保存到操作数栈，然后在出栈保存到局部变量表中。

栈帧操作：

![image-20220407204425267](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220407204425267.png)

![img](https://img-blog.csdnimg.cn/20210323203253851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**本地方法栈**：和虚拟机栈非常相似。区别：虚拟机栈是为虚拟机的方法进行操作，本地方法栈是为本地方法服务。在HotSpot虚拟机中和Java虚拟机合二为一。

## 进程通信

![img](https://img-blog.csdnimg.cn/20210424121540659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210424121528475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**什么方式通信最快**

共享内存是最快的

实现原理：当**两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存**，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用信号量来实现同步与互斥。

## 僵尸进程

运行程序的时候，一个父进程可能会有多个子进程跑

子进程**执行完毕后**会**发送一个exit()信号**，**父进程没有去处理**，导致这个子进程一直在进程表中。

解决方法：

1.重启服务器电脑

2.找到僵尸进程的父进程杀掉 kill -9，而不是去杀僵尸线程。

## 孤儿进程

**父进程退出后**，而它的子进程**还在运行**，那么这些子进程就是孤儿进程。

**解决方法：**

成了孤儿进程后，有init进程对它进行操作，最后孤儿进程在init进程下结束生命周期。

## 物理内存和虚拟内存

物理内存：硬件实际的内存大小，比如常见的500G硬盘，32G的U盘等。500G、32G指的是物理内存

虚拟内存：是计算机系统中一种内存管理技术，因为计算机内存的造价比较高，一般常见内存8G，而计算机的应用软件都是在内存中运行，每个应用都会占一定的内存，这就导致一个问题，如果计算机同时运行很多软件，使计算机的内存空间很容易被占满，那么计算机就无法运行用户的下一个应用了，直到空出足够的内存。虚拟内存技术就是解决用户内存不足的问题，当执行程序占用了大部分内存，导致当前内存不足以支撑下一个应用时，系统便会”拿”出一部分物理内存来充当内存使用。具体操作流程是这样的，**程序运行的时候，可以先将一部分需要运行的程序装入内存，剩余部分暂且放在外存，当这部分运行结束需要运行下一部分时，将已运行的部分从内存转移到外存，同时将外存需要的那部分转移到内存**，这样就可以避免因为内存不足引起的程序无法运行的问题。

## 创建线程

创建线程有**三种方式**，分别是**继承Thread类**、**实现Runnable接口**、**实现Callable接口**。

1. 继承Thread类来创建并启动线程的步骤如下：
   - 定义Thread类的子类，并重写该类的run()方法，该run()方法将作为线程执行体。
   - 创建Thread子类的实例，即创建了线程对象。
   - 调用线程对象的start()方法来启动该线程。

```java
//方法一  继承Thread类，重写run()方法，调用start()开启线程
//线程开启不一定立即执行，由CPU调度执行
public class TestThread1 extends Thread{
    public void run(){
        System.out.println("chm-线程");
    }
}

class MyThread{
    public static void main(String[] args) {
        TestThread1 thread = new TestThread1();
        thread.start(); 
    }
}
```

2. 实现Runnable接口来创建并启动线程的步骤如下：
   - 定义Runnable接口的实现类，并实现该接口的run()方法，该run()方法将作为线程执行体。
   - 创建Runnable实现类的实例，并将其作为Thread的target来创建Thread对象，Thread对象为线程对象。
   - 调用线程对象的start()方法来启动该线程。

```java
//方式二：实现Runnable接口
public class TestThread1 implements Runnable {
    public void run(){
        System.out.println("chm-线程");
    }
}

class MyThread{
    public static void main(String[] args) {
        TestThread1 testThread1 = new TestThread1();
        new Thread(testThread1).start();
    }
}
```

3. 实现Callable接口来创建并启动线程的步骤如下：
   - 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。
   - 使用**FutureTask类来包装Callable对象**，该FutureTask对象封装了该Callable对象的call()方法的返回值。
   - 使用**FutureTask对象作为Thread对象的target**创建并启动新线程。
   - 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

```java
public class TestThread1 implements Callable {
    public Integer call(){
        System.out.println("chm-线程");
        return 1;
    }
}

class MyThread{
    public static void main(String[] args) {
        FutureTask futureTask = new FutureTask(new TestThread1());
        new Thread(futureTask, "AA").start();
        System.out.println(futureTask.get());
    }
}
```

通过继承Thread类、实现Runnable接口、实现Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是**Callable接口里定义的方法有返回值，可以声明抛出异常而已**。因此可以将实现Runnable接口和实现Callable接口归为一种方式。

采用实现Runnable、Callable接口的方式创建多线程的优缺点：

- 线程类只是**实现了Runnable接口或Callable接口，还可以继承其他类。**
- 在这种方式下，**多个线程可以共享同一个target对象**，所以**非常适合多个相同线程来处理同一份资源的情况**，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
- 劣势是，**编程稍稍复杂**，如果需要访问当前线程，则必须使用Thread.currentThread()方法。

采用继承Thread类的方式创建多线程的优缺点：

- 劣势是，因为线程类已经**继承了Thread类，所以不能再继承其他父类**。
- 优势是**，编写简单，**如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。

鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

## 说说Thread类的常用方法

Thread类常用构造方法：

- Thread()
- Thread(String name)
- Thread(Runnable target)
- Thread(Runnable target, String name)

*其中，参数 name为线程名，参数 target为包含线程体的目标对象。*

Thread类常用静态方法：

- **currentThread()**：返回当前正在执行的线程；
- **interrupted()**：返回当前执行的线程是否已经被中断；
- **sleep(long millis)**：使当前执行的线程睡眠多少毫秒数；
- **yield()**：使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行；

Thread类常用实例方法：

- getId()：返回该线程的id；
- **getName()**：返回该线程的名字；
- **getPriority()**：返回该线程的优先级；
- **interrupt()**：使该线程中断；
- **isInterrupted()**：返回该线程是否被中断；
- **isAlive()**：返回该线程是否处于活动状态；
- isDaemon()：返回该线程是否是守护线程；
- setDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程；
- **setName(String name)**：设置该线程的名字；
- **setPriority(int newPriority)**：改变该线程的优先级；
- join()：等待该线程终止；
- join(long millis)：等待该线程终止,至多等待多少毫秒数。

## **堆和方法区**

堆和方法区是所有线程共享的资源，其中**堆是最大的一块内存**，主要**存放新创建的对象**；方法区主要用于存放**已被加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

## **并发和并行的区别**

**并发：**同一个时间段，多个任务都在执行(交替执行)。

**并行：**单位时间内，多个任务同时执行。

## **为什么要用多线程**

**从当代互联网发展趋势来说**：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

***\*从计算机底层来说**：

**单核时代：**多线程主要是为了提高CPU和IO设备的综合利用率。举个例子：当只有一个线程的时候会导致CPU计算的时候，IO设备会空闲；IO设备操作的时候，CPU计算会空闲。所以这边实际利用率只有50%，如果有两个线程的话，我们就可以用一个CPU计算，一个用IO操作。这样操作的话就可以利用率就可以是100%

**多核时代：**为了提高CPU利用率，假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU只会一个CPU核心被利用到，而创建多个线程的话，那么每个线程都可以用到单独的CPU核心，提交CPU的利用率。

## **使用多线程可能带来哪些问题？**

并发编程的目的就是为了能**提高程序的执行效率和提高程序运行速度**，但是并发编程并不总是能提高程序运行速度，而且并发编程可能会遇到很多问题，比如：**内存泄漏、上下文切换、死锁**。

## **线程的生命周期和状态**

**新建（New）**、**就绪（Ready）**、**运行（Running）**、**阻塞（Blocked）**和**死亡（Dead）**5种状态。

当线程启动以后，它不可能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、就绪之间切换。

- new关键字创建了一个线程之后，该线程就处于**新建**状态，此时它和其他的Java对象一样，仅仅由**Java虚拟机为其分配内存，并初始化其成员变量的值**。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。

- 当线程对象调用了**start()**方法之后，该线程处于**就绪**状态，**Java虚拟机会为其创建方法调用栈和程序计数器**，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度

- 如果处于就绪状态的线程**获得了CPU**，开始执行**run**()方法的线程执行体，则该线程处于**运行**状态，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。

- 当一个线程开始运行后，它不可能一直处于运行状态，线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务。当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。当发生如下情况时，线程将会进入**阻塞**状态：

  - 线程调用**sleep()**方法主动放弃所占用的处理器资源。        调用sleep()方法的线程经过了指定时间。

  - 线程调用了一个**阻塞式IO方法**，在该方法返回之前，该线程被阻塞。        线程调用的阻塞式IO方法已经返回。

    **阻塞式IO（BIO）方法**

    ​		在读取数据的时候，要阻塞当前线程，当所有数据读取完毕后才会被唤醒

  - 线程试图获得一个**同步监视器**（锁 ），但该同步监视器**正被其他线程所持有**。        线程成功地获得了试图取得的同步监视器。

  - 线程在**等待**某个**通知**（notify）。       线程正在等待某个通知时，其他线程发出了一个通知。

  - 程序调用了线程的**suspend**()方法将该线程挂起。但这个方法容易**导致死锁**，所以应该尽量避免使用该方法。           处于挂起状态的线程被调用                                   1                                                                                                                                                                                                了resume()恢复方法。

- 线程会以如下三种方式结束，结束后就处于死亡状态：

  - run()或call()方法**执行完成**，线程正常结束
  - 线程**抛出**一个未捕获的**Exception**或**Error**。
  - 直接调用该线程的**stop**()方法来结束该线程，该方法**容易导致死锁**，通常不推荐使用。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/B6700F052B8C52C28D140E41896513FE.png)

## 如何实现线程同步？

1. 同步方法

   即有**synchronized**关键字修饰的方法，由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。需要注意， synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。

2. 同步代码块

   即有**synchronized**关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。需值得注意的是，同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

3. **ReentrantLock**

   Java 5新增了一个java.util.concurrent包来支持同步，其中**ReentrantLock类是可重入、互斥、实现了Lock接口的锁**，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。需要注意的是，ReentrantLock还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，因此不推荐使用。

4. **volatile**

   volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。

5. **原子变量**

   在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如A**tomicInteger** 表可以**用原子方式更新int的值**，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

## 说一说Java多线程之间的通信方式

1. **wait()、notify()、notifyAll()**

   如果线程之间采用**synchronized**来保证线程安全，则可以利用**wait()、notify()、notifyAll()**来实现线程通信。这三个方法都不是Thread类中所声明的方法，而是**Object类中声明的方法**。原因是每个对象都拥有锁，所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作。并且因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。另外，这三个方法都是**本地方法**，并且被**final修饰**，**无法被重写**。

   **wait**()方法可以让当前**线程释放对象锁**并**进入阻塞状态**。**notify()**方法用于**唤醒**一个正在**等待相应对象锁的线程**，使其进入**就绪**队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。**notifyAll()**用于**唤醒所有正在等待相应对象锁的线程**，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。**不能保证哪个线程会被唤醒，这取决于线程调度器。**

   每个锁对象都有两个队列，一个是**就绪队列**，一个是**阻塞队列**。**就绪队列存储了已就绪**（将要竞争锁）的**线程**，**阻塞队列**存储了**被阻塞的线程**。当一个阻塞线程**被唤醒**后，才会进入**就绪队列**，进而**等待CPU**的调度。反之，当一个线程**被wait后**，就会进入**阻塞队列**，等待被**唤醒**。

2. **await()、signal()、signalAll()**

   如果线程之间采用**Lock**来保证线程安全，则可以利用**await()、signal()、signalAll()**来实现线程通信。这三个方法都是**Condition**接口中的方法，该接口是在Java 1.5中出现的，它用来替代传统的wait+notify实现线程间的协作，它的使用依赖于 Lock。相比使用wait+notify，**使用Condition的await+signal这种方式能够更加安全和高效地实现线程间协作。**

   Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 。 必须要注意的是，Condition 的 await()/signal()/signalAll() 使用**都必须在lock保护之内**，也就是说，必须**在lock.lock()和lock.unlock之间**才可以使用。事实上，await()/signal()/signalAll() 与 wait()/notify()/notifyAll()有着天然的对应关系。即：Conditon中的await()对应Object的wait()，Condition中的signal()对应Object的notify()，Condition中的signalAll()对应Object的notifyAll()。

3. **BlockingQueue**

   Java 5提供了一个BlockingQueue接口，虽然BlockingQueue也是**Queue**的**子接口**，但它的主要用途并不是作为容器，而是作为线程通信的工具。BlockingQueue具有一个特征：当**生产者线程试图向BlockingQueue中放入元素时**，**如果该队列已满，则该线程被阻塞**；**当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。**

   程序的**两个线程通过交替向BlockingQueue中放入元素、取出元素，**即可很好地控制线程的通信。线程之间需要通信，最经典的场景就是生产者与消费者模型，而BlockingQueue就是针对该模型提供的解决方案。

## 如何实现子线程先执行，主线程再执行？

启动子线程后，立即调用**该线程的join()方法**，则**主线程必须等待子线程执行完成后再执行。**

Thread类提供了让一个线程等待另一个线程完成的方法——join()方法。当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。

## **说说sleep()和wait()方法区别和共同点？**

1. sleep()是**Thread类**中的静态方法，而wait()是**Object类**中的成员方法；
2. sleep()可以在**任何地方使用**，而wait()只能在**同步方法或同步代码块**中使用；
3. sleep()**不会释放锁**，而wait()**会释放锁**，并需要通过**notify()/notifyAll()**重新获取锁。

## **什么是上下文切换？**

**多线程编程中一般线程个数大于CPU核心的个数**，而**一个CPU核心在任意时刻只能被一个线程使用**，为了让这些线程得到有效执行，CPU采用的策略是**为每个线程分配时间片并轮转形式**，当**一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用**，这就是一次上下文切换。

上下文切换都需要纳秒级的时间，相对于系统来说意味着**消耗着大量的CPU时间**，事实上，**可能是操作系统中时间消耗最大的操作。**

## **什么是线程死锁？如何避免死锁？**

### **认识线程死锁**

**多个线程同时被阻塞**，他们中的一**个或者全部都在等待某个资源被释放**。由于线程被无限期地阻塞，因此此程序不可能正常终止。

如下图所示，有两个线程A,B，两个资源1,2，线程A持有的资源2，线程B持有资源1，他们**同时都想申请对方的资源**，所以这两个线程**就会互相等待而进入死锁状态。**

![img](https://img-blog.csdnimg.cn/20210323203353628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)



产生死锁的四个条件：

1. **互斥条件**：该资源任何一个时刻只由一个线程占有。

2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

3. **不剥夺条件**：线程已获得的资源在未使用之前不能被其他线程强行剥夺，只能自己使用完后才释放资源。

4. **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。 P1等P2  P2等P3  P3等P1

自私，不让，不准抢，必须轮流

### **如何避免死锁？**

1. 破坏互斥条件：这个条件无法破坏，因为我们用锁本来就是让他们单独拥有

2. 破坏请求与保持条件：一次性把所有进程需要的资源全部拿走。这样就不会在运行的途中进行再去申请资源了。

3. 破坏不剥夺条件：以退为进。当某个线程申请不到资源的时候，把自己拥有的资源都释放

4. 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则**反序释放**。

## 为什么我们调用start()方法时会执行run()方法，为什么不直接调用run()方法？

run()方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而start()方法用来启动线程。		

当我们**new一个Thread**，线程进入**新建模式**。**调用start()方法**的时候才会让线程**进入就绪状态**，当**分配到时间片**就可以进行**运行**了。Start()方法会执行线程的准备工作，然后自动去执行run方法，这是真正的多线程工作。如果直接调用run(),只会把run方法当做Main线程中的普通方法调用，而不会进入某个线程调用，所以这并不是多线程工作。

总结：调用start()会让线程进入就绪状态并执行，直接调用run（）**不是以多线程工作**。 

## 线程是否可以重复启动，会有什么后果？

**只能对处于新建状态的线程调用start()方法**，否则将引发**IllegalThreadStateException**异常。

当程序使用**new**关键字创建了一个**线程**之后，该线程就处于**新建**状态，此时它和其他的Java对象一样，仅仅**由Java虚拟机为其分配内存**，并**初始化**其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。

当线程对象调用了**start()方法**之后，该**线程**处于**就绪**状态，Java虚拟机会为其**创建方法调用栈和程序计数器**，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始**运行**，取决于**JVM里线程调度器的调度**。

## **synchronized(锁)关键字**

1. **锁的原理**

​		在Java中每个对象都拥有一把锁，**锁放在对象头中，表示被那个线程占用**。

2. **对象、对象头结构**

​		![img](https://img-blog.csdnimg.cn/2021032320363896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210323203647285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

对象大小是8bit的倍数，所以需要填空字节

对象头比较小，包含**Mark word与Class Point**(指针指向当前对象类型所在方法区中的类型数据)

Mark word：32位JVM

![img](https://img-blog.csdnimg.cn/20210323203704383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

通过**锁标志位来标识这个对象是否上锁。**

3. **Sychronized**

解决的是**多个线程之间访问资源的同步性**，synchronized关键字可以**保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**

在Java早期版本中，synchronized属于重量级锁，效率低下。

为什么呢？

因为监视器锁是依赖于底层的操作系统的MutexLock 来实现的，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态切换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

Java6之后Java官方从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁清除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

锁只能升级不能降级。

4. **无锁（CAS是原子操作）**



## **说说自己是怎么使用synchronized关键字**

Synchronized关键字最主要的三种使用方式：

**修饰实例方法**：作用于**当前对象实例加锁**，进入同步代码前要获得当前对象实例的锁

![img](https://img-blog.csdnimg.cn/20210323204205752.png)

**修饰静态方法**：也就是给**当前类加锁**，会**作用于类的所有对象实例**，进入同步代码前获得当前class的锁。因为静态成员不属于任何一个实例对象，是类成员。所以，当我们线程A调用一个实例对象的非静态synchronized方法，线程B仍然可以调用该实例对象所属于类的静态synchronized方法。因为访问静态synchronized方法是占用的当前类的锁，而访问非静态synchronized方法占用的是当前实例对象的锁。
![img](https://img-blog.csdnimg.cn/2021032320422249.png)		

**修饰代码块**：指定**加锁对象，对给定对象/类加锁**。Synchronized(thisobject)表示进入同步代码库前要获得***\*给定对象的锁\****。Synchronized(类.class)表示进入同步代码前要获得当前class的锁。

![img](https://img-blog.csdnimg.cn/20210323204238682.png)

总结：

1.synchronized关键字加到static静态方法和synchronized（class）代码块上都是给Class类上锁

2.synchronized关键字加到非静态方法上是给实例对象加锁

3.**尽量不要**使用**synchronized(String a)**因为JVM中，**字符串常量池具有缓存效果**！

下面我们用一个常见面试题进行讲解synchronized关键字的具体作用。


## **双重校验锁实现对象单例(给重量级实例用的，线程池等，只会存在一个**

1.因为只有一个实例所以先写一个private static成员，保证一直都有

2.然后来一个外部接口在使用的时候创建实例。如果为Null后才会创建实例

![img](https://img-blog.csdnimg.cn/20210323204304926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

这样的话，可以在主函数任意new，肯定不行。所以要把公开的构造函数屏蔽掉。

![img](https://img-blog.csdnimg.cn/20210323204325287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

通过静态方法构造，这样new就不能构造。

单线程以上就够，但是多线程就会有问题了

![img](https://img-blog.csdnimg.cn/20210323204349118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210323204411465.png)

这样看着没问题，

因为太快了，所以停一会(实际开发)。为什么太快了会一样的。比如线程A都创建完了，然后线程B才进入，所以线程B就发现这个静态对应已经存在了，所以是一样的对象。

![img](https://img-blog.csdnimg.cn/20210323204426853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

结果就是两个实例了

![img](https://img-blog.csdnimg.cn/20210323204444254.png)

直接在getinstance方法加锁，只能一个线程走进来

![img](https://img-blog.csdnimg.cn/20210323204504752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

这样有没有必要锁这个方法。锁静态方法 实际上锁的是类。这样的锁粒度太大，我们每次创建的时候，都要锁类，这个操作太重。  

所以放入if块，双重检验。如果单层会出现这样的现象

![img](https://img-blog.csdnimg.cn/20210323204531858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

都进入了锁之前的地方，所以第一个线程创建完后，第二个线程跟进去继续又创建。所以就会有两个因此我们要在锁代码块内部还要添加一个 是否创立过。

![img](https://img-blog.csdnimg.cn/2021032320455813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

这样还不够完美。因为涉及到指令重排。

Javap 看反汇编看具体指令执行。 New的操作会执行这三部操作

![img](https://img-blog.csdnimg.cn/20210323204612267.png)

编译器 JIT cpu 可能会让我们指令重排

成下面这样

![img](https://img-blog.csdnimg.cn/20210323204625273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

比如T1进去后执行到2(把内存引用赋值给变量)，然后这个时候T3线程进来发现实例引用不为null，然后就直接返回。但是这次返回的是没有被初始化的实例。

怎么解决呢  在这个instance的变量加上**volatile**就不会重排序了

![img](https://img-blog.csdnimg.cn/20210323204639987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

```java
public class SingletonTest {
    public static void main(String[] args) {
        new Thread(()->{
            LazySingleton instance1 = LazySingleton.getInstance();
            System.out.println(instance1);
        }).start();
        new Thread(()->{
            LazySingleton instance2 = LazySingleton.getInstance();
            System.out.println(instance2);
        }).start();

    }
}

class LazySingleton{
    private volatile static LazySingleton instance;
    public static LazySingleton getInstance(){
        if(instance == null)
            synchronized (LazySingleton.class) {   //锁类
                if(instance == null)
                    instance = new LazySingleton();
            }
        return instance;
    }
    private LazySingleton() {
    }
}
```

## **构造方法可以使用synchronized关键字修饰么？**

 构造方法**不能使用synchronized关键字修饰**

 构造方法**本身就属于线程安全**的，不存在同步的构造方法一说

 构造方法是存在于**JVM的栈区**，本就是线程私有的。

## **讲一下synchronized关键字的底层原理**

Synchronized关键字底层原理属于JVM层面。

### synchronized同步语句块的情况

![img](https://img-blog.csdnimg.cn/20210323204719115.png)

通过JDK自带的javap命令查看SynchronizedDemo类的相关字节码信息：首先切换到类的对应目录执行javac SynchronizedDemo.java 命令生成编译后的.class文件，然后执行 javap -c -s -v -l ynchronizedDemo.class

![img](https://img-blog.csdnimg.cn/20210323204735205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

从上面我们可以看出：

Synchronized同步语句块的实现使用的是**monitorenter**和**monitorexit**指令，其中**monitorenter指令执行同步代码块的开始位置**，**monitorexit指令则执行同步代码块的结束位置**。

**当执行monitorenter指令时，线程试图获得锁也就是获得对象监视器monitor的持有权。**

在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个ObjectMonitor对象。

另外，wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出非法监视状态异常。

在执行monitorenter时，会尝试获得对象的锁，如果***\*锁的计数器\****为0则表示锁可以被获取，获取后将锁计算器设为1也就是加1。

如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外个线程释放为止。

在执行monitorexit指令后，锁的计数器会减1，表明锁被释放。

### synchronized修饰方法

![img](https://img-blog.csdnimg.cn/2021032320481318.png)

Synchronized修饰的方法并没有monitorenter和monitorexit指令，取而代之的是**ACC_SYNCHRONIZED**标识，该标识指明这个方法是同步方法。JVM可以通过该标识来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### 总结

Synchronized锁代码块的时候，是用monitor对象监视器，当进入的时候判断锁计数器是否为0，为零就可以执行monitorenter指令，计数器加1，否则一直等待其他线程释放锁。执行完同步代码块后，执行monitorexit指令，锁计数器-1

Synchronized锁方法的时候，会加上ACC_SYNCHRONIZED标识，让JVM识别出该方法是同步方法，直接作为同步方法处理。

## synchronized可以修饰静态代码块吗？

**不能修饰静态代码块。**

可以修饰静态方法,当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。

## 为什么要弄一个CPU高速缓存呢？

CPU缓存的是内存数据，用于**解决CPU处理速度与内存不匹配的问题**。**内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题**。

![img](https://img-blog.csdnimg.cn/2021032320485095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

如果两个线程一起获取i=1，进行i++，最后是i为2，但是应该是3的,为了避免这种问题我们可以通过制定一些**缓存一致协议**或者其他手段解决。

缓存一致性协议：当CPU写数据的时候，发现变量是**共享变量**，即在其他CPU中也存在该变量的副本，会发出信号通知***\*其他CPU将变量的缓存设置为***\*无效状态\****。因此在其他CPU读取这个变量的时候，发现是无效状态，会***\*重新\****去主存***\*取这个变量。

## 讲一下JMM(Java内存模型)

![img](https://img-blog.csdnimg.cn/20210323204916192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

JDK1.2之前，Java的内存模型是直接从主存里面去变量，这种方式没有什么需要注意的。但是现在的内存模型是，**线程可以把变量保存到本地内存(高速缓存)，而不是直接从主存读写**。这个可能操作一个线程修改了一个变量的值，而另一个线程还在用自己本地内存的变量。造成***\*数据不一致\****。

要解决这个问题，我们需要把变量设置为volatile，使得线程之间的变量可见。也就是volatile其中的一个重要性质保证***\*变量的可见性\****。

## 为什么有MESI(缓存一致协议)，还需要volatile关键词来保证可见性？

1.多核情况下，**MESI协议是弱一致性协议**，不能保证一个线程修改变量后，其他线程能立马可见，可能存在这一的情况，**当前线程修改了但是还没有刷新回主存，它又去做其他事了，其他线程重新去主存取的时候还是以前的值。**但是volatile可以保证可见性，**修改操作和刷回主存操作是一个原子操作**。

2.正确情况下，系统操作并不会进行缓存一致性的校验，只有变量被volatile修饰了，该变量所在的缓存行才被赋予一致性的校验功能。

## volatile关键字有什么用？

当一个变量被定义成volatile之后，它将具备两项特性：

1. **保证可见性**

   当写一个volatile变量时，JMM会把该线程**本地内存中的变量强制刷新到主内存中去**，这个写会操作会**导致其他线程中的volatile变量缓存无效**。

2. **禁止指令重排**

   使用volatile关键字修饰共享变量可以禁止指令重排序，volatile禁止指令重排序有一些规则：

   - 当程序执行到volatile变量的读操作或者写操作时，在**其前面的操作的更改肯定全部已经进行**，且结果已经**对后面的操作可见**，在其后面的操作肯定还没有进行；
   - 在进行指令优化时，**不能**将**对volatile变量访问的语句放在其后面执行**，也**不能把volatile变量后面的语句放到其前面执行**。

   即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。

注意，虽然volatile能够保证可见性，但它**不能保证原子性**。volatile变量在各个线程的**工作内存中是不存在一致性问题的，**但是Java里面的**运算操作符并非原子操作**，这导致volatile变量的运算在**并发下一样是不安全的**。

## 谈谈volatile的实现原理

volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“**内存屏障**”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会**多出一个lock前缀指令**，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：

1. 它**确保指令重排序时不会把其后面的指令排到内存屏障之前的位置**，也**不会把前面的指令排到内存屏障的后面**；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会**强制将对缓存的修改操作立即写入主存**；
3. 如果是**写操作**，它会**导致其他CPU中对应的缓存行无效**。

## 说说synchronized关键字和volatile关键字的区别

Synchronized关键字和volatile关键字是两个互补的存在，而不是对立的存在！

Volatile关键字是线程同步的***\*轻量级实现\****。所以volatile性能肯定比synchronized关键字要好。但是**volatile**关键字***\*只用于变量\****而**synchronized**关键字可以***\*修饰方法以及代码块\****。

Volatile关键字主要用于解决***\*多个线程之间的可见性\****，而synchronized关键字解决的是***\*多个线程之间访问资源的同步性\****。

## 说一说synchronized与Lock的区别

1. synchronized是**Java关键字**，在JVM层面实现加锁和解锁；Lock是一个**接口**，在代码层面实现加锁和解锁。
2. synchronized可以用在**代码块上、方法**上；Lock只能**写在代码里**。
3. synchronized在**代码执行完或出现异常时自动释放锁**；Lock**不会自动释放锁**，需要在finally中显示释放锁。
4. synchronized会导致线程**拿不到锁一直等待**；Lock可以设置获取锁失败的超时时间。
5. synchronized无法**得知是否获取锁成功**；Lock则可以通过tryLock得知加锁是否成功。
6. synchronized锁**可重入、不可中断、非公平**；Lock锁**可重入、可中断、可公平/不公平**，并可以细分读写锁以提高效率。

## 如果不使用synchronized和Lock，如何保证线程安全？

1. **volatile**

   **volatile关键字**为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。

2. **原子变量**

   在java的util.concurrent.atomic包中提供了创建了**原子类型变量**的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

3. **本地存储**

   可以通过**ThreadLocal**类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。

4. **不可变的**

   只要一个**不可变的对象**被正确地构建出来，那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态，“不可变”带来的安全性是最直接、最纯粹的。Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。String类是一个典型的不可变类，可以参考它设计一个不可变类。

## ThreadLocal了解么？

通常情况下，我们创建的变量可以被任何一个线程访问修饰的。如果想实现每一个**线程都有自己的专属本地变量**该如何解决呢？JKD中提供的ThreadLocal类正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子就不会出现这样的情况。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。  

### ThreadLocal原理

内部维护一个类似Map的**ThreadLocalMap**数据结构，**key为当前对象的Thread对象，值为Object对象**。

当前线程调用ThreadLocal的set和get方法时会调用ThreadLocalMap类对应的get、set方法。

![img](https://img-blog.csdnimg.cn/20210323204948925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210323205017952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

我们在同一个线程中声明了两个ThreadLocal对象的话，会使用Thread内部都是使用仅有那个ThreadLocalMap存放数据的，ThreadLocalMap的**key就是ThreadLocal对象，value就是ThreadLocal对象调用set方法设置的值。**

![img](https://img-blog.csdnimg.cn/20210323205057102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210323205109335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

## ThreadLocal内存泄漏问题了解不？

ThreadLocalMap中使用的**key**为ThreadLocal的**弱引用**，而**value值**为ThreadLocal的**强引用**，因此，如果**ThreadLocal在没有被外部强引用的情况下**，**在垃圾回收的时候，key会被清理掉**，而**value不会被清理掉**，这样的话ThreadLocalMap终究会**出现key为null的Entry，且不会被垃圾回收器回收**，这是就会**产生内存泄漏**。ThreadLocalMap**在调用set，get，remove方法时，会自动清理掉key为null的记录**，使用完ThreadLocal方法后最好**手动调用remove方法**。

## 说一说Java中乐观锁和悲观锁的区别

悲观锁：**总是假设最坏的情况，每次去拿数据的时候都认为别人会修改**，所以**每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过**synchronized**关键字或**Lock**接口来实现的。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁**适用于多读的应用类型**，这样可以**提高吞吐量**。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在**性能上有了很大的提升**。

## 公平锁与非公平锁是怎么实现的？

在Java中实现锁的方式有两种，一种是使用Java自带的关键字**synchronized**对相应的类或者方法以及代码块进行加锁，另一种是**ReentrantLock**，前者只能是非公平锁，而后者是默认非公平但可实现公平的一把锁。

ReentrantLock是基于其内部类FairSync(公平锁)和NonFairSync(非公平锁)实现的，并且它的实现依赖于Java同步器框架**AbstractQueuedSynchronizer（AQS）**，AQS使用一个整形的volatile变量state来维护同步状态，这个volatile变量是实现ReentrantLock的关键。我们来看一下ReentrantLock的类图：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/A72631473CC01A899A1A693A35194C44.jpeg)

ReentrantLock 的公平锁和非公平锁都委托了 AbstractQueuedSynchronizer#acquire 去请求获取。

```java
public final void acquire(int arg) { 
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))         
    	selfInterrupt(); 
}
```

- tryAcquire 是一个抽象方法，是公平与非公平的实现原理所在。
- addWaiter 是**将当前线程结点加入等待队列之中**。公平锁在锁释放后会严格按照等到队列去取后续值，而非公平锁在对于新晋线程有很大优势。
- acquireQueued 在**多次循环中尝试获取到锁或者将当前线程阻塞。**
- selfInterrupt 如果**线程在阻塞期间发生了中断，调用 Thread.currentThread().interrupt() 中断当前线程。**

公平锁和非公平锁在说的获取上都使用到了 volatile 关键字修饰的**state字段**， 这是保证多线程环境下锁的获取与否的核心。但是当并发情况下多个线程都读取到 state == 0时，则必须用到CAS技术，一门CPU的原子锁技术，可通过CPU对共享变量加锁的形式，实现数据变更的原子操作。volatile 和 CAS的结合是并发抢占的关键。

- 公平锁FairSync

  公平锁的实现机理在于每次有线程来抢占锁的时候，都会检查一遍有没有等待队列，如果有， 当前线程会执行如下步骤：

  ```java
  if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
      setExclusiveOwnerThread(current);     
      return true;  
  }
  ```

  其中hasQueuedPredecessors是用于**检查是否有等待队列的：**

  ```java
  public final boolean hasQueuedPredecessors() {
      Node t = tail; // Read fields in reverse initialization order     
      Node h = head;     
      Node s;     
      return h != t && 
          ((s = h.next) == null || s.thread != Thread.currentThread()); 
  }
  ```

- 非公平锁NonfairSync

  非公平锁**在实现的时候多次强调随机抢占：**

  ```java
  if (c == 0) {
  	if (compareAndSetState(0, acquires)) {   
  		setExclusiveOwnerThread(current);  
          return true;      
          } 
  } 
  ```

  与公平锁的区别在于新晋获取锁的进程会有多次机会去抢占锁，被加入了等待队列后则跟公平锁没有区别。

## 了解Java中的锁升级吗？

**JDK 1.6之前**，**synchronized 还是一个重量级锁**，是一个效率比较低下的锁。但是在JDK 1.6后，JVM为了提高锁的获取与释放效率对synchronized 进行了优化，引入了偏向锁和轻量级锁 ，从此以后锁的状态就有了四种：**无锁、偏向锁、轻量级锁、重量级锁。**并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即**不可降级**，这四种锁的级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁。如下图所示：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/1E93EF873A5A8C896878DBD7EB5E6C36.png)

1. 无锁

   无锁是指**没有对资源进行锁定**，**所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。**无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果**没有冲突就修改成功并退出，否则就会继续循环尝试**。**如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。**

2. 偏向锁

   初次执行到synchronized代码块的时候，锁对象变成**偏向锁**（通过CAS修改对象头里的锁标志位），字面意思是“**偏向于第一个获得它的线程”的锁**。执行完同步代码块后，线程并**不会主动释放偏向锁**。当**第二次到达同步代码块**时，线程会**判断此时持有锁的线程是否就是自己**（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就**不需要重新加锁**。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎**没有额外开销，性能极高**。

   偏向锁是指当**一段同步代码一直被同一个线程所访问时，**即**不存在多个线程的竞争**时，那么**该线程在后续访问时便会自动获得锁**，从而降低获取锁带来的消耗，即提高性能。

   当一个线程访问同步代码块并获取锁时，会在 Mark Word 里**存储锁偏向的线程 ID**。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。

   偏向锁只有遇到**其他线程尝试竞争偏向锁**时，**持有偏向锁的线程才会释放锁**，线程是**不会主动释放偏向锁**的。关于偏向锁的撤销，需要等待全局安全点，即在**某个时间点上没有字节码正在执行**时，它会**先暂停拥有偏向锁的线程**，然后**判断锁对象是否处于被锁定状态**。如果**线程不处于活动状态**，则**将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态**。

3. 轻量级锁

   轻量级锁是指当**锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁**，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。

   轻量级锁的获取主要由两种情况：

   1. 当**关闭偏向锁**功能时；
   2. 由于**多个线程竞争偏向锁**导致偏向锁**升级**为轻量级锁。

   一旦有**第二个线程加入锁竞争**，偏向锁就**升级为轻量级锁**（自旋锁）。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当**某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。**

   在轻量级锁状态下继续锁竞争，**没有抢到锁的线程将自旋**，即不停地循环判断锁是否能够被成功获取。**获取锁的操作**，其实就是通过**CAS修改对象头里的锁标志位**。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。

   **长时间的自旋操作是非常消耗资源**的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做**忙等**（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种**折中**的想法，**短时间的忙等，换取线程在用户态和内核态之间切换的开销。**

4. 重量级锁

   重量级锁显然，此忙等是有限度的（有个计数器记录自旋次数，默认**允许循环10次**，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会**将轻量级锁升级为重量级锁**（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁**是重量级锁**，则**直接将自己挂起**（而不是忙等），等待将来被唤醒。

   重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。简言之，就是所有的控制权都交给了操作系统，**由操作系统来负责线程间的调度和线程的状态变更。**而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。

synchronized 用的锁是存在Java对象头里的，那么什么是对象头呢？我们以 Hotspot 虚拟机为例进行说明，Hopspot 对象头主要包括两部分数据：**Mark Word（标记字段）** 和 **klass Pointer（类型指针）。**

- Mark Word：**默认存储对象的HashCode，分代年龄和锁标志位信息。**这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
- Klass Point：**对象指向它的类元数据的指针**，虚拟机通过这个指针来确定这个对象是哪个类的实例。

那么，synchronized 具体是存在对象头哪里呢？答案是：存在锁对象的对象头的Mark Word中，那么MarkWord在对象头中到底长什么样，它到底存储了什么呢？

在32位的虚拟机中：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/5DF8A992305ABEE9C57726EDF2726303.png)

在64位的虚拟机中：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/7E15B63D4078E33589B46C0F28D33490.png)

下面我们以 32位虚拟机为例，来看一下其 Mark Word 的字节具体是如何分配的：

- 无锁 ：对象头开辟 25bit 的空间用来存储对象的 **hashcode** ，4bit 用于存放对象**分代年龄**，1bit 用来存放**是否偏向锁的标识位**，2bit 用来存放**锁标识位**为**01**。
- 偏向锁： 在偏向锁中划分更细，还是开辟 25bit 的空间，其中**23bit 用来存放线程ID**，**2bit 用来存放 Epoch**，**4bit 存放对象分代年龄**，1bit 存放**是否偏向锁标识**， 0表示无锁，1表示偏向锁，**锁的标识位**还是**01**。
- 轻量级锁：在轻量级锁中直接**开辟 30bit 的空间存放指向栈中锁记录的指针**，**2bit 存放锁的标志位**，其标志位为**00**。
- 重量级锁： 在重量级锁中和轻量级锁一样，**30bit 的空间用来存放指向重量级锁的指针**，**2bit 存放锁的标识位**，为**11**。
- GC标记： 开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。

其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。关于内存的分配，我们可以在git中openJDK中 markOop.hpp 可以看出：

```java
public:   // Constants   
enum { 
    age_bits = 4,          
    lock_bits = 2,          
    biased_lock_bits = 1,          
    max_hash_bits = BitsPerWord - age_bits - lock_bits - biased_lock_bits,          
    hash_bits = max_hash_bits > 31 ? 31 : max_hash_bits,          
    cms_bits = LP64_ONLY(1) NOT_LP64(0),          
    epoch_bits = 2  
};
```

- age_bits： 就是我们说的分代回收的标识，占用4字节。
- lock_bits： 是锁的标志位，占用2个字节。
- biased_lock_bits： 是是否偏向锁的标识，占用1个字节。
- max_hash_bits： 是针对无锁计算的hashcode 占用字节数量，如果是32位虚拟机，就是 32 - 4 - 2 -1 = 25 byte，如果是64 位虚拟机，64 - 4 - 2 - 1 = 57 byte，但是会有 25 字节未使用，所以64位的 hashcode 占用 31 byte。
- hash_bits： 是针对 64 位虚拟机来说，如果最大字节数大于 31，则取31，否则取真实的字节数。
- cms_bits： 不是64位虚拟机就占用 0 byte，是64位就占用 1byte。
- epoch_bits： 就是 epoch 所占用的字节大小，2字节。

## 如何实现互斥锁（mutex）？

在Java里面，最基本的互斥同步手段就是**synchronized关键字**，这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成**monitorenter和monitorexit**这两个字节码指令。这两个字节码指令都需要一个**reference类型的参数**来指明要**锁定和解锁的对象**。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference。如果没有明确指定，那将**根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。**

自JDK 5起，Java类库中新提供了java.util.concurrent包（J.U.C包），其中的java.util.concurrent.locks.**Lock**接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。

## 分段锁是怎么实现的？

在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将同时导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是**独占锁**。

我们一般有三种方式降低锁的竞争程度：

1. 减少锁的**持有时间**；
2. 降低锁的**请求频率**；
3. 使用带有**协调机制的独占锁**，这些机制允许更高的并发性。

将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这称为分段锁。其实说的简单一点就是：**容器里有多把锁，每一把锁用于锁容器其中一部分数据**，那么当多线程**访问**容器里**不同数据段的数据**时，线程间就**不会存在锁竞争**，从而可以有效的**提高并发访问效率**，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

如下图，JDK1.7的**ConcurrentHashMap**使用**Segment**数据结构，将数据分成**一段一段的存储**，然后给**每一段数据配一把锁**，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。所以说，ConcurrentHashMap在并发情况下，不仅保证了线程安全，而且提高了性能。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/9797535B1B5D6A0FD9ED762715EBAA72.png)

## 说说你对读写锁的了解

与传统锁不同的是读写锁的规则是**可以共享读**，但**只能一个写**，总结起来为：读读不互斥、读写互斥、写写互斥，而一般的独占锁是：读读互斥、读写互斥、写写互斥，而场景中往往读远远大于写，读写锁就是为了这种**优化**而创建出来的一种机制。 注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。

在Java中ReadWriteLock的主要实现为**ReentrantReadWriteLock**，其提供了以下特性：

1. **公平性选择**：支持公平与非公平（默认）的锁获取方式，吞吐量非公平优先于公平。
2. **可重入**：读线程获取读锁之后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁。
3. **可降级**：写线程获取写锁之后，其还可以再次获取读锁，然后释放掉写锁，那么此时该线程是读锁状态，也就是降级操作。

## **线程池**

### **为什么要使用线程池**

线程池提供一种限制和管理资源。每个线程池还护卫一些基本统计信息。例如已完成任务的数量。

使用线程池的好处：

1.***\*降低资源的消耗\****。通过重复利用已经创建的线程降低线程创建和销毁造成的消耗。

2.***\*提高响应速度\****。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

3.***\*提高线程的可管理性\****。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### **实现Runnable接口和Callable接口的区别**

在ThreadPoolExecutor类中，执行线程池有两种方法：submit（）、execute()

在ExecutorService中的submit方法中，输入参数有callable与runnable。Runnable接口不会返回任何结果或抛出异常，但是Callable接口可以。

![img](https://img-blog.csdnimg.cn/2021032320522371.png)

![img](https://img-blog.csdnimg.cn/20210323205230159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

Runnable实现主要核心功能，其他辅助逻辑还是交给Thread来实现

虽然通过继承Thread可以实现多线程，但是继承是由单继承限制的，不利于自定义的多线程类扩充其他的功能，二通过实现Runnable接口则没有这个限制，源码中，Thread也是实现了Runnable接口，Thread是Runnable的子类

### **执行execute()方法和submit()方法的区别是什么？**

1. execute()方法用于提交**不需要返回值**的任务，所以无法判断任务是否被线程池执行成功与否。

2. **submit**()方法用于提交**需要返回值**的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成。

### **如何创建线程池**

《阿里巴巴Java开发手册》中强制线程池不允许是用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程的运行规则，规避资源耗尽的风险。

![img](https://img2020.cnblogs.com/blog/1988929/202104/1988929-20210412001333949-1361376523.png)

因此就有两种方式创建线程池：Executors和ThreadPoolExecutor。

Executors的三个方法是静态的，直接Executors.方法名；**线程池三大方法**

- ExecutorService threadPool = Executors.**newSingleThreadExecutor()**; // 单个线程

- ExecutorService threadPool2 = Executors.**newFixedThreadPool(5)**; // 创建一个固定大小的线程池

- ExecutorService threadPool3 = Executors.**newCachedThreadPool()**; // 可伸缩的

```java
// Executors 工具类，3大方法
public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 单个线程
//        ExecutorService threadPool = Executors.newFixedThreadPool(5); // 创建一个固定的线程池的大小
//        ExecutorService threadPool = Executors.newCachedThreadPool(); // 可伸缩的

        try {
            for (int i = 0; i < 100; i++) {
                // 使用线程池后，使用线程池创建线程
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName() + " ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}
```

ThreadPoolExecutor里是普通方法，所以需要new ThreadPoolExecutor；**七大参数**

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

// 本质：三大方法都是开启 ThreadPoolExecutor 即：
public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小
                          int maximumPoolSize, //最大的线程池大小
                          long keepAliveTime,  //超时了没有人调用就会释放
                          TimeUnit unit, //超时单位
                          BlockingQueue<Runnable> workQueue, //阻塞队列
                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动
                          RejectedExecutionHandler handler //拒绝策略
                         ) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

### ThreadPoolExecutor类分析  

 里面主要是***\*七大参数，四大拒绝策略\****

七大参数

![img](https://img-blog.csdnimg.cn/20210323205359127.png)

1.核心线程数：一般情况下工作的线程数

2.最大线程数：最大可以开的线程数

3.阻塞队列：核心线程数都满了，来的线程就要放入阻塞队列

4.存活时间：如何核心线程空闲一定时间后就关闭线程池

5.存活时间的单位：存活时间的单位

6.线程工厂:创建线程的工厂类

7.拒绝策略：阻塞队列都满了，还来线程怎么处理呢？4种拒绝策略

**四大拒绝策略：**

1.中断抛出异常

2.默默丢弃任务，不进行任何通知

3.丢弃掉在队列中存在时间最久的任务

4.让提交任务的线程去执行任务

```java
* new ThreadPoolExecutor.AbortPolicy() // 该拒绝策略为：超出最大承载，就会抛出异常
* new ThreadPoolExecutor.CallerRunsPolicy() // 该拒绝策略为：哪来的去哪里 main线程进行处理
* new ThreadPoolExecutor.DiscardPolicy() // 该拒绝策略为：队列满了,丢掉异常，不会抛出异常
* new ThreadPoolExecutor.DiscardOldestPolicy() // 该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常
```

### 线程池原理分析

![img](https://img-blog.csdnimg.cn/202103232054335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

提交任务

查看是否核心线程数满了    否   创建线程执行任务

​											   是   阻塞队列workQueue是否满了   否   将任务加入阻塞队列

​															 												 是   查看最大线程数有没有满   否  继续创建线程执行任务

​																												 												 是  执行拒绝策略

## **介绍一下Atomic原子类**

指一个**操作是不可中断**的。即使是在多个线程一起执行的时候，**一个操作一旦开始就不会被其他线程干扰**。

原子类说简单点就是具有原子/原子操作特征的类。

并发包JUC的原子类都存放在JUC.atomic下，如图

![img](https://img-blog.csdnimg.cn/20210323205456256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

## **JUC包中的原子类是那4类？**

### 基本类型

![img](https://img-blog.csdnimg.cn/2021032320551133.png)

### **数组类型**

![img](https://img-blog.csdnimg.cn/20210323205532854.png)

### **引用类型**

![img](https://img-blog.csdnimg.cn/20210323205547339.png)

### 对象的属性修改类型

![img](https://img-blog.csdnimg.cn/20210323205601733.png)

## 介绍一下ReentrantLock？

ReentantLock基于AQS，内部实现了两个队列的抽象类，分别是**同步队列**和**条件队列**。其中**同步队列是一个双向链表**，里面**储存的是处于等待状态的线程**，正在**排队等待唤醒去获取锁**，而**条件队列是一个单向链表**，里面**储存的也是处于等待状态的线程**，只不过这些**线程唤醒的结果是加入到了同步队列的队尾**，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。

在同步队列中，还存在2中模式，分别是**独占模式和共享模式**，这两种模式的区别就在于AQS在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应**独占锁和共享锁**。

在并发编程中它可以实现公平锁(不允许插队)和非公平锁(允许插队)来对共享资源进行同步，同时，和synchronized一样，ReentrantLock支持可重入，除此之外，ReentrantLock在调度上更灵活，支持更多丰富的功能。ReentrantLock就是通过重写了AQS的tryAcquire和tryRelease方法实现的lock和unlock。

实现的是Lock接口

三个内部类：sync NonfairSync FairSync

![img](https://img-blog.csdnimg.cn/20210323205718179.png)

Sync是继承了AQS，所以AQS的方法Sync都可以使用。NonfairSync、FairSync是Sync的唯二子类。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/2F192BDFAD9C22C62FE4D23692FDE892.png)

首先ReentrantLock 实现了 Lock 接口，然后有3个内部类，其中Sync内部类继承自AQS，另外的两个内部类继承自Sync，这两个类分别是用来公平锁和非公平锁的。通过Sync重写的方法tryAcquire、tryRelease可以知道，ReentrantLock实现的是AQS的独占模式，也就是独占锁，这个锁是悲观锁。

**AQS的核心思想**是，如果**被请求的共享资源空闲**，则将**当前请求资源的线程**设置为**有效的工作线程**，并将**共享资源设置为锁定状态**，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**

用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

Sync类中除了lock(公平与不公平实现不一样)和readObject(用于反序列化)方法，其他的方法都是final修饰，不可子类修改。为什么要被final修饰？第一反应这些方法应该是对AQS的一些方法封装，并且本身实现已经完整，不想被外部修改。

![img](https://img-blog.csdnimg.cn/20210323205736183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**NonfairTryAcquire**()

```java
final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {        //c为0表示锁空闲
                if (compareAndSetState(0, acquires)) {    //CAS操作更改state
                    setExclusiveOwnerThread(current);	  //将当前线程设置为独占线程
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {   //判断当前线程是否为独占线程
                int nextc = c + acquires;       //可重入锁：某个线程已经获得一个锁，再次获取锁时不会出现死锁
                if (nextc < 0) // overflow		//判断state的次数，因为Int为32位，只要超过了就会溢出成为负数，所以重入的次数就是无符号的最大值。
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);				//修改共享资源state
                return true;
            }
            return false;
}
```

非公平的尝试获得锁:

1.获取state，如果为0，锁状态为空闲，并可以一次CAS原子更改state,将当前线程设为独占线程，并返回true，否则返回false。

2.判断当前线程是否为独占线程，这就是现实可重入性，可重入性指的是单个线程重新进入同一个子程序，仍是线程安全的。比如A线程在某上下文中获取了锁，当A线程又想获得该锁，不会因为自己占有该锁而一直等待，假如A线程既获得了锁，又在等待自己释放锁，那就死锁了。简单来说，一个线程可以不用释放可以获得锁n次，但是释放也要n次。

判断state的次数，因为Int为32位，只要超过了就会溢出成为负数，所以重入的次数就是无符号的最大值。

**TryRelease**()

```java
protected final boolean tryRelease(int releases) {
      int c = getState() - releases;
      if (Thread.currentThread() != getExclusiveOwnerThread())
          throw new IllegalMonitorStateException();
      boolean free = false;
      if (c == 0) {
          free = true;
          setExclusiveOwnerThread(null);
      }
      setState(c);
      return free;
}
```

释放锁，返回值是布尔。代表的是是否全部释放完成，不是释放了锁就返回true。要**完全释放锁才可以返回true**。

**其余方法**

![img](https://img-blog.csdnimg.cn/20210323205834104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

newCondition：新建一个Condition对象

getOwner：获取正在占用锁的那个线程对象

getHoldCount：获取state的数值

isLock：判断锁是否空闲

### **NonfairSync**

非公平锁：不按照请求的顺序分配，可能线程永远得不到锁，但是性能比公平锁好。可能有违常识，在现实生活中，排队肯定比哄抢的效率高，但是为什么锁却不一样了？因为在唤醒一个线程的时候，***\*线程切换\****之间会产生***\*短暂的延时\****，非公平锁可以利用这点时间去完成操作，非公平锁在一些情况下比公平锁更好。

无论前面有没有线程在等待，直接CAS操作获取锁，没有成功的话就会调用AQS的acquire()方法。

```java
static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        /**
         * Performs lock.Try immediate barge, backing up to normal
         * acquire on failure.
         */
        final void lock() {
            if (compareAndSetState(0, 1))         //一上来就CAS操作获取锁
                setExclusiveOwnerThread(Thread.currentThread());  //设置独占线程
            else
                acquire(1);     //失败的话执行AQS的acquire()方法
        }

        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
```

```java
public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

1、第一步通过tryAcquire()尝试获取锁，成功则返回

2、获取锁失败后通过addWaiter添加到CLH队列的末尾

3、添加CLH队列后，通过acquireQueued()方法逐步的去执行CLH队列的线程，如果当前线程获取到了锁则返回；否则当前线程进行休眠，直到唤醒并重新获取锁后返回。

**TryAcquire的实现**

```java
protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
```

1、如果锁未占用的情况下：当前线程直接抢占锁并设置锁占用线程为当前线程，**非公平锁NonfairSync和FairSync的差别就在于这个地方，非公平锁直接抢占锁，而公平锁则需要判断是否位于头结点来决定是否抢占。**

2、如果锁被占用的情况下：判断当前线程是否是占用锁线程，如果是则实现锁的可重入功能，设置锁占用次数。

3、如果上述全否那么就返回占锁失败的。

### **FairSync**

公平锁：按照请求的顺序分配，线程肯定可以得到锁，性能比非公平锁低。

```java
static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;

        final void lock() {
            acquire(1);
        }

        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
```

不像非公平锁，不会直接去抢锁，而是直接执行acquire()

```java
public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

Acquire首先会调用tryAcquire，没有获取成功则会进入FIFO队列乖乖直到获得锁

```java
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```

**tryAquire的实现：**

1.获得锁的状态state

2.如果state为0，说明锁状态为空闲。看阻塞队列中是否有线程，没有线程就去尝试获得锁。如果获取获取失败就返回false。

3.其中还会进行当前线程是否是独占线程，如果是的话，就把加锁次数+1，然后加锁次数小于0了，说明溢出了，那么超过最大加锁次数了。抛出异常。然后更新加锁状态。

**ReentrantLock的构造方法：**

```java
public ReentrantLock() {
        sync = new NonfairSync();
    }

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    }
```

无参构造是默认非公平加锁

有参构造，看传入的是否为true或false，true就是代表公平加锁

其中构造好了就无法修改加锁状态了。

### **Lock**与LockInterruptibibly的区别：

Lock:是调用的AQS的acquire。优先考虑获取锁，如果**线程在排队等待锁的过程中(使用LockSupport.park),被调用了中断，那么该线程不会抛出中断异常，而是存储中断状态，等待获得锁后才会抛出中断异常。**

LockInterruptibily:是调用了AQS的acquireInterruptibly方法，该方法在线程的排队等待锁中，调用了中断，那么就会放弃等待锁，直接抛出中断异常。

### **TryLock**

```java
public boolean tryLock() {
        return sync.nonfairTryAcquire(1);
    }
    
public boolean tryLock(long timeout, TimeUnit unit)
            throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }
```

tryLock(long time, TimeUnit unit) 的作用在**给定等待时长内锁没有被另外的线程持有**，并且**当前线程也没有被中断,则获得该锁**，通过该方法可以实现锁对象的限时等待。

tryLock()仅在调用时锁定未被其他线程持有的锁，如果**调用方法时，锁对象对其他线程持有，则放弃，调用方法尝试获得没，如果该锁没有被其他线程占用则返回true表示锁定成功**; 如果锁被其他线程占用则返回false,不等待。

**Unlock**  释放锁



## **介绍下AQS？**

多个线程去操作同一块空间的时候，到底谁执行那个线程的代码呢？为了节约时间一般都是采用谁先到就运行谁。为了避免当前线程在运行的时候，其他线程来骚扰，所以就进行加锁操作。加锁的过程步骤挺多的，而且线程调度的内容(获得锁，阻塞，唤醒等)都是相同的，所以就专门用AQS对这些线程调度进行管理。那些锁类就去专注实现自己线程的逻辑即可。

AQS就是一个***\*同步管理框架\****。

**AQS的成员变量**

![img](https://img-blog.csdnimg.cn/20210323210145147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**1. state**

表示同步状态，其中有独占模式和共享模式，独占模式一个线程，但是共享模式就会有很多个线程，因为要表示线程的数量所以用上了int而不是Boolean。

**2. head**

**3. tail**

如果线程想获取资源，但是被别的线程占用，该线程就要进入一个FIFO队列

**AQS的主要方法**

![img](https://img-blog.csdnimg.cn/20210323210244670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

1. **tryAcquire()**

```java
protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
```

被protected修饰，只能被子类调用，并且必须要被重写，不重写就抛出异常

公平锁和非公共锁实现方式不同：

1. 都是先判断当前锁是否被其他线程占用，如果state为0，CAS操作修改state，然后设置独占线程。
2. 如果获取失败，非公平锁执行acquire方法，公平锁则进入队列等待锁

3. **acquire()**

```java
public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

是final修饰的方法，不允许修改和重写，

首先执行tryAcquire()方法，如果没有获得锁就会acquireQueued排队等待锁

3. **addWriter()**

```java
private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
```

将线程封装为Node，加入等待队列操作，返回值为当前的节点。

1.先建立一个Node对象

2.顺理成章插入尾节点。

其中的细节，if(CAS)是原子性的，但是if里面的内容不是原子性的，但是，就算其他线程来了，pre指针已经更新了，所以也不影响。

3.如果第一次CAS失败或者首节点为空，会进入完成的入队方法enq();

4. **enq()**

```java
private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

1.自旋，等待加入队列或建立头指针。

2.加入尾节点：1.判断尾节点是否为空，为空直接设置头结点；

​						   2.如果不为空，将新节点的前置指针连接到尾节点，然后CAS操作将新节点设置为尾节点，然后将旧的尾节点的next指向新尾节点。

为什么会在addWaiter会进行快速入队，而不是直接进行完整入队，因为完整入队在自旋，判空操作是耗性能的。

5. **acquireQueued()**

```java
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {//死循环
                final Node p = node.predecessor();//获得该node的前置节点
                /**
                * 如果前置节点是head，表示之前的节点就是正在运行的线程，表示是第一个排队的
（一般讲队列中第一个是正在处理的，可以想象买票的过程，第一个人是正在买票(处理中)，第二个才是真正排队的人）；
那么再去tryAcquire尝试获取锁，如果获取成功，说明此时前置线程已经运行结束，则将head设置为当前节点返回
                **/
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC，将前置节点移出队列，这样就没有指针指向它，可以被gc回收
                    failed = false;
                    return interrupted;//返回false表示不能被打断，意思是没有被挂起，也就是获得到了锁
                }
                
                /**shouldParkAfterFailedAcquire将前置node设置为需要被挂起，
                    注意这里的waitStatus是针对当前节点来说的，
                    即是前置node的ws指的是下一个节点的状态**/
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())//挂起线程 park()
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);//如果失败取消尝试获取锁(从上面的代码看只有进入p == head && tryAcquire(arg)这个逻辑是才会触发，这个时候前置节点正好在当前节点入队的时候执行完，当前节点正好获得锁，具体的代码以后分析)
        }
    }
//看到因为是死循环，所以当执行到parkAndCheckInterrupt()时，当前线程被挂起，等到某一天被unpark继续执行，这个时候已经是对头的第二个节点了，那么就会进入if (p == head && tryAcquire(arg))逻辑获取到锁并结束循环
```



6.**shouldParkAfterFailedAcquire()**

```java
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * 前驱节点已经设置了SIGNAL，闹钟已经设好，现在我可以安心睡觉（阻塞）了。
             * 如果前驱变成了head，并且head的代表线程exclusiveOwnerThread释放了锁，
             * 就会来根据这个SIGNAL来唤醒自己
             */
            return true;
        if (ws > 0) {
            /*
             * 发现传入的前驱的状态大于0，即CANCELLED。说明前驱节点已经因为超时或响应了中断，
             * 而取消了自己。所以需要跨越掉这些CANCELLED节点，直到找到一个<=0的节点
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            /*
             * 进入这个分支，ws只能是0或PROPAGATE。
             * CAS设置ws为SIGNAL
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
```

- 如果前驱节点的状态为SIGNAL，说明闹钟标志已设好，返回true表示设置完毕。
- 如果前驱节点的状态为CANCELLED，说明前驱节点本身不再等待了，需要跨越这些节点，然后找到一个有效节点，再把node和这个有效节点的前驱后继连接好。
- 如果是其他情况，那么CAS尝试设置前驱节点为SIGNAL。

由于shouldParkAfterFailedAcquire函数在acquireQueued的调用中处于一个死循环中（独占锁对应的是acquireQueued里的死循环，共享锁对应的是doAcquireShared的死循环），且因为shouldParkAfterFailedAcquire函数若返回false，那么此函数必将至少执行两次才能阻塞自己。

7.**parkAndCheckInterrupt()**

```java
private final boolean parkAndCheckInterrupt() { 
	LockSupport.park(this); 
	return Thread.interrupted(); 
}
```

使用LockSupport.park挂起当前线程编程WAITING状态

Thread.interrupted，返回**当前线程是否被其他线程触发过中断请求**，也就是thread.interrupt(); 如果有触发过中断请求，那么这个方法会返回当前的中断标识true，并且对中断标识进行复位标识已经响应过了中断请求。如果返回true，意味着在acquire方法中会执行selfInterrupt()。

**进队列挂起总结：**

对AcquireQueue分析，

![img](https://img-blog.csdnimg.cn/20210323210602927.png)

先回进行判断当前节点的**前置节点是否为Head,**如果**是head会自旋一直等待锁**，直到**拿锁成功**。否则会进行**判断是否需要挂起**。

判断是否需要挂起，条件是这样，当前节点是否有除了Head节点的其他节点，再看其他节点的state，如果是SINGNAL就挂起，如果大于0，是CANNEL状态，就会删除，其他状态会被置成SINGNAL，为以下轮询的线程方便挂起。  这样就可以避免大量的自旋浪费CPU，一直挂着，肯定要进行释放，不是就一堆线程挂起。

8.**tryRelease和Release**

```java
protected boolean tryRelease(int arg) {
        throw new UnsupportedOperationException();
}
```

tryRelease也是给上层开放空间的源码。

```java
public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
```

```java
private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
```

1.先把首节点的状态置为0，防止它干扰其他状态的判断

2.然后从尾节点开始搜索，找到除了head节点之外最靠前的(非head)且state<0的节点，然后进行唤醒，起来工作。

3.唤醒的线程会继续执行acquireQueue方法，拿锁。然后就可以在这里阻塞跳出，然后进行任务执行。



9.**Interrupted值**

其中调用wait,sleep方法,其中其他线程把该线程中断，该线程会直接抛出中断异常，但是通过LockSupport.park进行挂起，是不会直接抛出中断异常，会记录在interrupted里面表示中断的状态值，外部调用了中断，就会成true。当执行完acquireQueue方法后，就会把这个中断状态带出外部，就会走到acquire的selfInterrupt方法，然后进行线程中断。


## ReentrantLock和Sychronized的区别

相似点：1.**加锁方式同步**，而且都是阻塞式的同步，也就是说当一个线程获得了对象锁，进入了同步快，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的(操作系统在用户态和内核态之间来回切换，代价很高，不过可以通过对锁进行优化进行改善)

功能区别：1.**Sychronized**，它是java语言的**关键字**，是原生语法层面的互斥，需要Jvm实现。而**ReentrantLock**是JDK1.5之后提供的API层面的**互斥锁**，需要lock和unlock方法配置try/finally语句来完成。

便利性：**Sychronized的使用比较方便**，并且由**编译器去保证锁的加锁和释放**，而**ReentrantLock需要手工去加锁和释放锁**，为了避免忘记手工释放造成死锁，所以最好在finnaly中声明释放锁。

锁的**细粒度和灵活度**：很明显**ReentrantLock优于Synchronized**

性能的区别：在Sychronized优化以前，它的性能比ReentrentLock性能差很多的，但是自从Synchronized引入偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况，官方建议使用Synchronized，其实synchronized的优化我感觉就是借鉴了ReentrantLock的CAS技术。