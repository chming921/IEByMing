# 计网

## OSI与TCP/IP各层的结构与功能，都有哪些协议？

![img](https://img-blog.csdnimg.cn/20210208215524435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

其中表示层和会话层都会归结到应用层，从上到下的层级解释：

1. **应用层**

应用层的任务是通过***\*应用进程\****间的交互来完成特定网络应用。应用层协议定义的应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，比如**域名系统DNS**，万维网的**HTTP协议**，邮件系统的**SMTP协议**。我们把应用层交互的数据称为**报文**。

2. **运输层**

运输层的主要任务就是负责向两台**主机进程之间的通信**提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。“通用”是指并不是针对某一个特定的网络应用，而是**多种应用可以使用同一个运输服务**。由于一台主机可以同时运行多个线 程，因为运输层有复用和分用的功能。**复用**：多个应用进程可以同时使用下面运输层的服务；**分用**;运输层把收到的信息分别交付上面应用层中的相应进程。

主要协议：TCP，UDP

3. **网络层**

在计算机网络中进行通信的两个计算机之前会有很多个数据链路，所以网络层的任务就是选择合适的**网间路由**和**交换结点**，确保数据及时**传输** 。在发送数据的时候，网络层会把**运输层的报文段或用户数据**封装**成组或包**进行传送。由于网络层使用IP协议，因此分组也叫**IP数据报**，简称数据报。

网络层协议是无连接的网际协议和许多路由选择协议，因此互联网的网络层也叫网际层或IP层。

**有了运输层为什么还要网络层？**

**应用之间的通信**与**设备之间的通信**是两件事。 应用的通信是怎么将**应用数据**合适、安全的**到达目的地**。 设备的通信是**一个封包到了一个路由器怎么传递到另外一个设备去**，解决的是更具体的一个问题。

4. **数据链路层**

数据链路层是因为两台**主机之间传输数据**的时候，总是在**一段一段的链路上传送**的，这就需要使用专门的链路层的协议。数据链路层就会**把网络层的IP数据报封装成帧**，在两个节点间的链路上传送帧。

在接受数据的时候，控制信息使接收端知道从哪个比特开始读取，哪个比特读取完毕。这样，数据链路层在收一个一个帧后，就可从中提出数据部分，上交给网络层。还可以利用控制信息进行差错检验。

5. **物理层**

在物理层上所传送的数据单位是**比特**。

物理层的作用是实现相邻**计算机节点之间比特流的透明传送，**尽可能**屏蔽掉具体传输介质和物理设备**的差异。透明传送就是说，传输的过程中，我的比特流是不变的，相当于实际电路是不存在的。

## TCP三次握手和四次挥手

### 三次握手

TCP是运输层的协议，所以该协议为了保证运输的准确性。然后进行三次握手。

![img](https://img-blog.csdnimg.cn/20210208215810768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

SYN(确认发送到接收)：***\*同步序列编号\****，是TCP/IP建立连接时使用的握手信息。

ACK(确认接收到发送)：***\*确认字符\****，表示发来的数据已经确认无误。

既然是传输的TCP报文，那么我们来看看TCP报文长什么样子！

![img](https://img-blog.csdnimg.cn/20210208215838762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第一次客户端发送：客户机发起连接请求，将SYN(同步序列编号)位设置为1，同时客户端选择了一个初始序列号x,并存在TCP报文段的序号中。

![img](https://img-blog.csdnimg.cn/20210208215900991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第二次服务端发送：服务端接收到该报文后，会为其**分配TCP缓存和变量**(这使得TCP容易受到SYN**洪泛攻击**的拒绝服务攻击)，服务端会返回一个报文到客户端，其中**SYN标志号为1**，**ack置1**，**确认号设置为x+1**。然后并选一个自己的**初始序列号y**,放置到序号字段中。

![img](https://img-blog.csdnimg.cn/20210208215917872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第三次客户端发送：客户端收到服务端发来的报文后，客户端也要给该链接分配缓存和变量，然后再次发送一个确认报文给服务端，其中**SYN**置0**，ack置1**，将确认号设置为**y+1**，另外该报文段是可以携带数据：

![img](https://img-blog.csdnimg.cn/20210208215950489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**为什么是三次握手**

三次握手的目的是**建立可靠的通信信道**，而三次握手最主要的目的就是双方**确认自己与对方的发送与接收是正常的**。

**为什么传回SYN**

接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信号信息确实就是你所发送的信号，**确认是发送方发送的信号**。

**传SYN，为什么还要传回ACK**

双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送端发到接收方的通道没有问题，但是接收端到发送端的通道还需要ACK信号来进行验证。

**第三次握手失败后，怎么办**

如果第三次失败，**过了超时计时器**，服务端会**重新发第二次的报文**，要求**客户端重传第三次报文**，默认是**5次**，如果默认次数到了，**还没有**的话。服务端就**关闭连接**。

**SYN攻击，如何防范**

SYN洪泛攻击就是利用**第一次握手报文**，服务器会**为客户端请求分配缓存**，那么黑客就可以利用假的ip疯狂去建立TCP连接，服务器会不断缓存，把服务器的连接资源消耗完。

服务器有SYN Cookie进行有效防御。当**第一次报文来的时候，不给缓存**，然后把**第二次报文发给你客户端，客户端返回第三次报文的时候**，检查无误，才**建立具有套接字的全开的连接**。但是有个缺点，第三次握手失败后，因为没有缓存，所以会重新三次握手。

### 四次挥手

![img](https://img-blog.csdnimg.cn/20210208220124518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第一次发报文：客户端发起连接释放的请求，设置**FIN为1**，**序号会随机算出u**；发送完毕后，客户端进入FIN-WAIT-1状态。

![img](https://img-blog.csdnimg.cn/20210208220142610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第二次发送报文：服务端接收到FIN报文后，会返回一个ACK报文，将**ACK设置1**，确认号为**u+1**;表明自己**接受到了客户端关闭连接的请求**，但还没有准备好关闭连接。发送完毕后，服务端会进入CLOSE-WAIT状态，客户端接受到这个确认包之后，进入FIN-WAIT-2状态，等待服务器端关闭连接
![img](https://img-blog.csdnimg.cn/20210208220204731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第三次报文：服务端准备好进行关闭时，想客户端发送一个结束连接请求，**FIN置为1**；发送完毕后，服务端进入LAST-ACK状态，等待来自客户端的最后一个ACK；

![img](https://img-blog.csdnimg.cn/20210208220225156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

第四次报文：**客户端收到第三次报文**，知道服务器已经准备好关闭，客户端发送一个确认包，并进入TIME-WAIT状态，等待可能出现的要求重传的ACK报文；服务端收到这个确认包后，关闭连接，进入CLOSE状态；

客户端等待了某个固定时间之后(**2倍最大段周期**)，没有收到服务器的ACK，认为服务端已经正常关闭，于是自己也关闭连接，进入CLOSE状态。

**四次挥手重要的是TIME-WAIT状态，为什么需要这个状态呢**

要确保服务器是否收到了我们的ACK报文，如果没有收到的话，服务器会重新发FIN报文给客户端，那么客户端再次收到FIN报文之后，就知道之前的ACK报文丢失了，就会再次发送ACK报文。

**为什么握手只要三次，挥手要四次**

关键在于中间两步。

当**客户端发了第一次报文**的时候，**服务端先告诉客户端你那边的关闭请求**我**收到**了。但是我这边还有一些资源，你等等我。 然后当**服务端传完资源**后，在**发一个FIN报文**，说我这边有可以关闭了。所以这里会多一次服务端准备好关闭的流程。

**为什么TIME-WAIT状态需要2MSL才能转换到CLOSE状态**

2MSL是**一个发送**和**一个回复**所**需要的最大时间**。

### TCP和UDP的区别

![img](https://img-blog.csdnimg.cn/20210208220339296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210208220354457.png)

### TCP如何保证可靠传输

1. 应用数据被分割成TCP认为**最适合发送**的**数据块**

2. TCP给发送的每一个**包编号**，接收方对**数据包**进行**排序**，把有序数据传送给应用层。

3. 校验和：这是**端到端**的校验和，目的是**检验数据在传输过程中的任何变化**。如果变化，就不接受

4. TCP的接收端会**丢弃重复的数据**

5. **流量控制**：TCP连接的每一方都有固定的缓冲空间，TCP的接收端值允许发送端发送接收端能够接纳的数据。

6. **拥塞控制**：当网络拥塞时，减少数据的发送。

7. **ARQ协议**：每发完一个分组就停止发送，等待对方确认。收到确认后再发下一个分组。

8. **超时重传**：TCP发出一个段，会启动一个定时器，没有及时收到一个确认，会重新发。

### ARQ协议

自动重传请求是OSI模型中**数据链路层和传输层**的**错误纠正协议**之一。他通过使用***\*确认\****和***\*超时\****这两个机制，在**不可靠服务的基础上实现可靠的信息传输**。如果发送方在发送一段时间之内没有收到确认帧，它通常会重新发送。

### 滑动窗口和流量控制

TCP利用***\*滑动窗口\****实现***\*流量控制\****。***\*流量控制\****是为了**控制发送方发送速率**，**保证接收方来得及接受**。接收方发送的确认报文中的***\*窗口字段\****可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。 

![image-20220426170000394](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220426170000394.png)

### 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。拥塞控制就是为了**防止过多的数据注入到网络中**，这样就可以使网络中的路由器或链路不致过载。

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并能动态变化。发送方让自己的发送窗口取为取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，**慢开始、拥塞避免、快重传、快恢复**。

慢开始：先**从小到大逐渐增大发送窗口**

拥塞避免：**拥塞窗口慢慢变大**

快重传和快恢复：他能够**快速恢复丢失的数据包**，服务端发给客户端报文的时候，是不对的，然后这边客户端有了FRR，就会让他重复确认，如果受到了**三个重复确认**，他会假定**数据段丢失**，直接**重传**这些丢失的，就**不需要等待计时器过时**。

## 在浏览器输入url地址->显示主页的过程

![img](https://img-blog.csdnimg.cn/20210208220510478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

1. DNS解析(域名解析)

2. TCP连接

3. 发送HTTP请求

4. 服务器处理请求并返回HTTP报文

5. 浏览器解析渲染页面

6. 连接结束

## 状态码

![img](https://img-blog.csdnimg.cn/20210208220533214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

## 各种协议与HTTP协议之间的关系

![img](C:/Users/chm/Desktop/Java学习/面经.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70.png)

## HTTP长连接、短连接

在HTTP/1.0中默认使用**短连接**。客户端和服务器**每一次Http操作**，就**建立一次连接**，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，**每遇到**这样**一个Web资源**，浏览器就会**重新建立一个HTTP会话**。

而从HTTP/1.1起，默认使用**长连接**，用以**保持连接特性**。使用长连接的HTTP协议，**TCP连接不会关闭**，客户端**再次访问服务器**的时候，会**继续使用**已经建立好的**连接**，但是也不是永久保持，有一个保持时间。

## HTTP是不保存状态的协议，如何保存用户状态

HTTP是一种不保存状态，即无状态协议。也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。

**Session机制**的存在就是为了解决这个问题，Session的主要作用就是通过**服务端记录用户的状态**。经典的场景是购物车，当你要添加商品到购物车的时候，系统不知道是那个用户的，因为HTTP协议是无状态的。服务端给特定的用户创建特定的Session之后就可以表示这个用户并且跟踪这个用户。

保存Session的方法很多，最常用的就是内存和数据库(内存是**redis**保存)

如果Cookie被禁用了，可以通过URL重写把SessionID附加到URL路径的后面。

## Cookie的作用是什么？和Session的区别是什么？

Cookie和Session都是用来**跟踪浏览器用户身份**的会话方式，但是两者的应用场景不太一样。

**Cookie**一般通过***\*客户端\****用来保存用户信息：

1.我们在**Cookie中保存已经登录过得到用户信息**，下次访问网页的时候页面可以自动帮你登录一些基本信息。

2.还可以用作**保持登录**，下次在访问的时候不需要重新登录。因为用户登陆的时候我们存放了一个Token在Cookie中，下次登陆的时候只需要根据Token值来查找用户即可(为了安全考虑，是被重写了的)

**Session**的主要作用就是通过***\*服务端\****记录用户的状态：

1.经典例子就是**购物车**，当你要添加商品到购物车，系统不知道那个用户操作的，因为HTTP协议是无状态的。服务端给特定的用户创建完Session后就可以标识用户并跟踪这个用户了。

## HTTP各代版本

**HTTP0.9**

​	采用的纯文本，只是验证Web服务的可用性

**HTTP1.0**

- 增加了**HEAD、POST**等新方法
- 增加了**响应状态码**，标记可能的错误原因
- 引入了**协议版本号**概念
- 引入了**HTTP Header**的概念，让HTTP**处理请求和响应更加灵活**
- 传输的数据**不再仅限于文本**

**HTTP1.1**

- 增加了**PUT、DELETE**等新的方法；
- 增加了**缓存管理和控制**；
- 明确了**连接管理**，允许**持久连接**；
- 允许**响应数据分块**，利于**传输大文件**；
- 强制要求**Host头**，让互联网主机托管成为了可能。

**HTTP2**

- **二进制协议**，不再是纯文本
- 可**发起多个请求**，废弃了1.1里的管道
- 使用专用的算法**压缩头部**，**减少数据传输量**
- 允许**服务器主动向客户端推送数据**
- 增强了**安全性**，要求加密通信

![img](https://img-blog.csdnimg.cn/20210208220813345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**HTTP3**

HTTP/2对前面性能已经增加了很多了，但是有一个局限在于:TCP。

因为**2中采用了多路复用的TCP**，采用一个TCP去传输多个资源，如果其中**一个资源丢了**，那么**整个资源都需要重新传**，这样一来，可能性能还没有1.x的好。因为1.x是每个资源一个TCP，所以丢那个就直接重传那个即可。

3 出来就是解决这个问题，3 使用**UDP的QUIC协议**。

  QUIC协议有三个新功能：

  ①**多路复用**：但是基于UDP的，就算其中有一个资源丢包，也不需要把全部资源重传，只需要单独传被丢失的那个包。

  ②**加密认证的报文**：因为TCP协议头部没有任何加密和认证，所以在传输过程中容易被中间网络设备篡改，注入和窃听。QUIC将所有**报文头、报文Body都经过加密**，只要对QUIC报文有任何修改，接收端都能及时发现。

  ③**向前纠错**：传输的每个**数据包**都**包含了其他数据包的数据**，如果其中**一个丢包了**，可以**从其他包的冗余数据直接组装而无需重传**。但是出现**丢了多个包**，也只有**重传**。

## URI和URL区别

URI(Uniform Resource Identified)是**统一资源标志符**，可以**唯一表示一个资源**。

URL(Uniform Resource Location)是**统一资源定位符**，可以**提供该资源的路径**。它是一种URI，即**URL可以用来标识一个资源**，而且还指明了如何定位这个资源。

## HTTP和HTTPS的区别

**端口**

HTTP的默认端口是**80**，HTTPS的默认端口是**443**。

**安全性和资源消耗**

**HTTP协议**运行在**TCP**之上，所有**传输的内容**都是**明文**，**客户端和服务器端都无法验证对方的身份**。**HTTPS**是运行在**SSL/TLS之上的HTTP协议**，所有**传输的内容**都经过**加密**，加密采用**对称加密**，但**对称加密的密匙**用**服务器方的证书**进行了**非对称加密**。所以说，**HTTP安全性没有HTTPS高**，但是HTTPS比HTTP消耗更多服务器资源。

**对称加密**

**密匙只有一个**，**加密解密为同一个密码**，加解密的速度快。算法有DES、AES等。

**非对称加密**

**密匙成对出现**(**公钥无法推知私钥，根据私钥无法推知公钥**)，**加密解密使用不同密匙**(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称加密速度较慢，非对称加密算法RSA

- 

