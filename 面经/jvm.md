# jvm

## JVM包含哪几部分？

JVM 主要由四大部分组成：**ClassLoader**（类加载器），**Runtime Data Area**（运行时数据区，内存分区），**Execution Engine**（执行引擎），**Native Interface**（本地库接口），下图可以大致描述 JVM 的结构。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/9602C6323C6B86C4EDA164DB052D8420.jpeg)



首先需要准备好**编译好的 Java 字节码文件**（即class文件），计算机要运行程序需要先通过一定方式（**类加载器**）将 **class 文件加载到内存中**（运行时数据区），但是字节码文件是JVM定义的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解释器（**执行引擎**）将字节码**翻译**成特定的操作系统**指令集**交给 **CPU 去执行**，这个过程中会需要**调用**到一些不同语言为 Java 提供的接口（例如驱动、地图制作等），这就用**到了本地 Native 接口**（本地库接口）。

- **ClassLoader**：负责加载字节码文件即class文件，class 文件在文件开头有特定的文件标示，并且 ClassLoader 只负责class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。
- **Runtime Data Area**：是存放数据的，分为五部分：Stack（虚拟机栈），Heap（堆），Method Area（方法区），PC Register（程序计数器），Native Method Stack（本地方法栈）。几乎所有的关于 Java 内存方面的问题，都是集中在这块。
- **Execution Engine**：执行引擎，也叫 Interpreter。Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 JVM 指令集翻译为操作系统指令集。
- **Native Interface**：负责调用本地接口的。他的作用是调用不同语言的接口给 JAVA 用，他会在 Native Method Stack 中记录对应的本地方法，然后调用该方法时就通过 Execution Engine 加载对应的本地 lib。原本多用于一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。

## JVM是如何运行的？

JVM的启动过程分为如下四个步骤：

1. JVM的**装入环境和配置**

   java.exe负责**查找JRE**，并且它会按照如下的顺序来选择JRE：

   - **自己目录**下的JRE；
   - **父级目录**下的JRE；
   - 查**注册中**注册的JRE。

2. **装载JVM**

   通过第一步找到JVM的路径后，**Java.exe通过LoadJavaVM来装入JVM文件**。LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。

3. **初始化JVM**，获得本地调用接口

   调用InvocationFunction -> CreateJavaVM，也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例。

4. **运行Java程序**

   JVM运行Java程序的方式有两种：jar包 与 class。

   运行jar 的时候，java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用JarFileJNIEnv类中getManifest()，从其返回的Manifest对象中取getAttrebutes("Main-Class")的值，即jar 包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。

   运行Class的时候，main函数直接调用Java.c中的LoadClass方法装载该类。

## 介绍一下Java代码的编译过程

从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。

1. 准备过程：初始化插入式注解处理器。

2. **解析与填充符号表**过程，包括：

   - 词法、语法分析，将源代码的字符流转变为标记集合，构造出抽象语法树。
   - 填充符号表，产生符号地址和符号信息。

3. **插入式注解处理器**的**注解处理**过程：

   在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。

4. **分析与字节码生成**过程，包括：

   - 标注检查，对语法的静态信息进行检查。
   - 数据流及控制流分析，对程序动态运行过程进行检查。
   - 解语法糖，将简化代码编写的语法糖还原为原有的形式。
   - 字节码生成，将前面各个步骤所生成的信息转化成字节码。

上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如图所示。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/D5A5CF19C86BD497E892012DFFC26B0E.jpeg)

## Java程序是怎么运行的？

Java 源代码文件经过 **Java 编译器编译成字节码文件**后，通过**类加载器加载到内存**中，才能**被实例化**，然后到 **Java 虚拟机中解释执行**，最后通过**操作系统操作 CPU 执行**获取结果。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/2B33427D8F51F7F8EADC74E0034C5FC7.jpeg)



## 介绍一下java内存区域

**jdk1.8之前**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210408142107124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjY1NzQ1,size_16,color_FFFFFF,t_70)

**jdk1.8**

![img](https://img-blog.csdnimg.cn/20210207005913352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

线程私有的：

- 虚拟机栈
- 本地方法栈
- 程序计数器

线程共有的：

- 堆
- 方法区
- 直接内存   直接内存主要被 Java NIO 使用，某种程度上也就是指**DirectByteBuffer对象占用的堆外内存。 可以看出，直接内存的大小并不受到java堆大小  的限制，甚至不受到JVM进程内存大小的限制。 它只受限于本机总内存（RAM及SWAP区或者分页文件）大小以及处理器寻址空间的限制**



**程序计数器**

## 介绍一下对象的实例化过程

对象实例化过程，就是执行类构造函数对应在字节码文件中的**<init>()方法**(**实例构造器**)，<init>()方法由**非静态变量、非静态代码块以及对应的构造器**组成。

- <init>()方法**可以重载**多个，类有几个构造器就有几个<init>()方法；
- <init>()方法中的代码执行顺序为：父类变量初始化、父类代码块、父类构造器、子类变量初始化、子类代码块、子类构造器。

静态变量、静态代码块、普通变量、普通代码块、构造器的执行顺序如下图：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/9285BA6FB2D1E24A711E876B40F6E978.png)

具有父类的子类的实例化顺序如下：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/7F511C22AD3C8FA49BFA8D92452E6CB3.png)

Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？

当Java虚拟机遇到一条字节码new指令时，首先将**去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。**

在类加载检查通过后，接下来虚拟机将**为新生对象分配内存**。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞**”（Bump The Pointer）。但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“**空闲列表**”（Free List）。选择哪种分配方式由**Java堆是否规整**决定，而Java堆是否规整又由所采用的垃圾收集器**是否带有空间压缩整理**（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在**并发情况**下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是**对分配内存空间的动作进行同步处理**——实际上虚拟机是**采用CAS配上失败重试的方式保证更新操作的原子性**；另外一种是**把内存分配的动作按照线程划分在不同的空间之中进行**，即**每个线程在Java堆中预先分配一小块内存**，称为**本地线程分配缓冲**（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。

内存分配完成之后，虚拟机必须将**分配到的内存空间（但不包括对象头）都初始化为零值**，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

接下来，Java虚拟机还要对对象进行必要的设置，例如这个**对象是哪个类的实例**、**如何才能找到类的元数据信息**、**对象的哈希码**（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、**对象的GC分代年龄**等信息。这些信息存放在**对象的对象头**（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，**对象头**会有不同的**设置**方式。

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着**执行<init>()方法**，**按照程序员的意愿对对象进行初始化**，这样一个真正可用的对象才算完全被构造出来。

## java类实例化时，java的执行顺序？

1. 父类静态代码块
2. 父类静态变量
3. 子类静态代码块
4. 子类静态变量
5. 父类成员变量赋值
6. 父类构造方法开始执行
7. 子类成员变量赋值
8. 子类构造方法执行

![img](C:/Users/chm/Desktop/Java学习/面经.assets/7F511C22AD3C8FA49BFA8D92452E6CB3.png)



```java
public class Test{
    public static void main(String[] args) {
        Son son = new Son();
    }
}

class parent{
    private static int a = 1;
    private static int b;

    private int c = init();
    
    static{
        System.out.println("父类静态代码块");
    }

    parent(){
        System.out.println("父类构造方法");
    }

    {
        System.out.println("父类非静态代码块");
    }

    private int init()
    {
        System.out.println("父类成员变量赋值");
        return 3;
    }
}

class Son extends parent{
    private static int a = 1;
    private static int b;

    private int c = init();

    private int init()
    {
        System.out.println("子类成员变量赋值");
        return 3;
    }

    static{
        System.out.println("子类静态代码块");
    }

    {
        System.out.println("子类非静态代码块");
    }

    Son(){
        System.out.println("子类构造方法");
    }
}
```

![image-20220424212547333](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424212547333.png)

## JVM虚拟机进程何时结束生命周期

执行了 **System.exit()** 方法或 **Runtime.getRuntime().exit();**

程序**正常执行结束**

程序在执行过程中遇到了**异常**或**错误**而异常终止

由于**操作系统出现错误**导致java虚拟机进程结束

## JVM类的加载机制

三个阶段：加载、连接、初始化

连接又分为三个阶段：验证、准备、解析

![image-20220422211146751](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422211146751.png)

**加载阶段**：将类的**.class文件**中的 **二进制数据读入到内存**中，将其放在运行时数据区的**方法区**内，然后再**堆内创建一个class对象**，用来**封装**类在方法区内的**数据结构**。

**加载class文件的方式**：

从本地系统中直接加载

通过网络下载.class文件

从zip，jar等归档文件中加载.class文件

从专有数据库中提取.class文件

将java源文件动态编译为.class文件

![image-20220422211206777](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422211206777.png)

类的加载**最终产品**是位于**堆**中的**class对象**。class对象封装了类在方法区中的数据结构，并向java程序员**提供了访问方法区内的数据结构和接口**

类加载不会等到某个类被主动使用的时候才会加载，jvm规范允许类加载器在预料到某个类要被使用的时候就预先加载。如果预先加载过程中报错，类加载器必须在首次主动使用的时候才会报错，如果类一直没有被使用，就不会报错。

**验证阶段**

验证内容如下

- 类文件的结构检查：

​		确保类文件遵从java类文件的**固定头格式**，就像平时做文件上传验证文件头-一样；还会验证文件的**主次版本号**，确保当前class文件的版本号被当前的jvm兼容。验证类的**字节流**是否完整，根据md5码进行验证。

- 语义检查

​		检查这个类是否存在**父类**，父类是否合法，是否存在。

​		检查该类是不是**final**，是否被继承，被final修饰的类是不允许被继承的。

​		检查该类的方法**重载**是否合法。

​		检查该类方法翻译后的**字节码流**是否合法。

​		验证当前类的其他类和方法是否能被**顺利找到**。

**准备阶段**

为**类中定义的变量**（即**静态变量，被static修饰的变量**）**分配内存**并设置**类变量初始值**的阶段

![image-20220422212525121](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422212525121.png)

**解析阶段**

解析阶段会把类中的**符号引用替换为直接引用**，比如Worker类的getoWork方法会引用car类的run方法。

在work类的二进制数据，包含了一个Car类的符号引用，有方法的全名和相关描述符组成。解析阶段，java虚拟机会把这个符号引用替换为一个指针，该指针指向car的run方法在方法区中的内存位置，这个指针即就是直接引用。

![image-20220422212849179](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422212849179.png)

**初始化阶段**（先父后子）

5.1 为静态变量赋值

5.2 执行static代码块

之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。

![image-20220422213055976](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422213055976.png)

## java类的初始化时机

类分为主动使用和被动使用。**主动使用类进行初始化**，**被动使用不会初始化**。

**主动使用**

1. **创建类的实例**
2. **反射**
3. **调用类的静态方法**
4. **初始化一个类的子类**
5. **访问**某个类或者接口的**静态变量**，或**对静态变量进行赋值**
6. 具有**main方法的java启动类**

![image-20220422213611275](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422213611275.png)

**被动使用**

1. 通过**子类引用父类的静态字段**，为子类的被动使用，不会导致子类初始化。

![image-20220422213740451](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422213740451.png)

![image-20220422213746637](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422213746637.png)

结果如下：

![image-20220422213820305](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422213820305.png)

虽然是以Dson.count形式调用的，但是因为count是Dfather的静态成员变量，所以只初始化Dfather类，而不初始化Dson类。

2. 通过**数组定义引用类**，为类的被动使用，不会触发此类的初始化

![image-20220422214326515](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422214326515.png)

![image-20220422214342163](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422214342163.png)

![image-20220422214349052](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422214349052.png)

3. **常量**在**编译阶段**会**存入**调用方法所在**类的常量池**中，再引用就是直接用常量池中的值了。

![image-20220422214706037](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422214706037.png)

![image-20220422214740997](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422214740997.png)

## 介绍一下java的类加载器

类加载器就是**把类加载到java虚拟机中的一种东西**。

对于任意的一个类，由她的**类加载器**和他的**类**本身**确立**其在jvm的**唯一性**。

java内置三大类加载器

![image-20220422215206081](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422215206081.png)

![image-20220422215505533](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422215505533.png)

![image-20220422215517541](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422215517541.png)

## 如何实现自定义类加载器

![image-20220422215703419](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422215703419.png)

## java类的双亲委派机制

当一个类加载器收到类加载的请求，并**不会直接加载**这个类，先去类加载器的**命名空间查找**这个类是否已经被加载，如果**已经被加载**，直接**返回**。如果**没有被加载**，先**请求父类加载器加载**，父类加载器也没法加载，就**再请求父类**，**直到根类加载器**，只有当**父加载器反馈自己无法完成**这个加载请求时，**子加载器**才会**尝试**自己去完成加载。

能够提高安全性，在此机制下，**用户自定义的类加载器不可能加载**应该**由父类加载器加载的可靠类**，从而防止恶意代码替代父类加载器。

```java
protected Class<?> loadClass(String name, boolean resolve)     throws ClassNotFoundException {     
synchronized (getClassLoadingLock(name)) {         
    // First, check if the class has already been loaded         
    Class<?> c = findLoadedClass(name);         
    if (c == null) {             
        long t0 = System.nanoTime();             
        try {                 
            if (parent != null) {                     
                c = parent.loadClass(name, false);                 
            } else {                     
                c = findBootstrapClassOrNull(name);                 
            }             
        } catch (ClassNotFoundException e) {                 
            // ClassNotFoundException thrown if class not found                 
            // from the non-null parent class loader             
        }              
        if (c == null) {                 
            // If still not found, then invoke findClass in order                 
            // to find the class.                 
            long t1 = System.nanoTime();                 
            c = findClass(name);                  
            // this is the defining class loader; record the stats
            PerfCounter.getParentDelegationTime().addTime(t1 - t0);                 
            PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                 
            PerfCounter.getFindClasses().increment();             
        }         
    }         
    if (resolve) {             
        resolveClass(c);         
    }         
    return c;     
} 
}
```

## java破坏双亲委派机制

![image-20220422220026474](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422220026474.png)

## Jvm的类的命名空间

![image-20220422220118899](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422220118899-16539648873301.png)

## 什么是jvm的运行时包？

![image-20220422221109242](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220422221109242.png)

## JVM加载类的缓存机制

每一个**类**在经过**加载之后**，在**虚拟机中就会有对应的class实例**，类C被类加载器CL加载，CL就是C的初始化类加载器。JVM**为每一个类加载器维护了一个类列表。**该列表**记录了将类加载器作为初始化类加载器的所有class**。在加载一个类的时候，类加载器现在这里面寻找。在类加载的过程中，只要是参与过类加载的，在类加载器的列表中都有这个类

## Jvm类的卸载

- 类的所有**实例**已经**被gc**
- **加载该类**的所有**classloader实例被回收**
- 该类的**class实例没有在其他地方引用**

## 对象创建的五种方式

1. **new 构造函数**
2. Class**类**的**newInstance方法** 相当于无参构造
3. **Constructor**类的**newInstance方法** （bClass.getConstructors() 可以按顺序获取所有构造函数）
4. **反序列化**
5. **clone**

```java
Class<B> bClass = B.class;
B b = bClass.newInstance();  // 2
System.out.println(b.getName());
Construntor<B> constructor[] = (Constructor<B>[]) bClass.getConstructors();
B b1 = constructor[0].newInstance("11",22);  //3
System.out.println(b1.getName()+b1.getAge());
```

## java是解释语言还是编译语言

是**解释型**的，虽然**java代码要编译成.class文件**，但是**编译后的.class文件不是二进制的机器可以直接运行的程序**，需要**通过java虚拟机**，进行**解释**才能**正常运行**。解释一句，执行一句。编译性的定义是编译过后，机器可以直接执行。也正是因为.class文件，使得jvm实现跨平台，一次编译到处运行。

## Jvm的内存区域

 ![image-20220423150123462](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220423150123462.png)

1. **程序计数器**

如果线程正在执行的是一个**Java方法**，这个计数器记录的是正在执行的**虚拟机字节码指令的地址**；如果正在执行的是**本地（Native）方法**，这个计数器值则应为**空**（Undefined）。唯一没有OOM的区域

程序计数器的作用：

1. 指示程序运行的标志，字节解释器通过程序计数器来一次读取程序命令，从而实现代码的流程控制。

2. 在多线程下，保存当前线程的状态，因为当某个线程运作的时候，可能时间片用完了，程序计数器就保留了运行到了某行，下次到了该线程的时候直接从这个行开始执行程序。

所以需要**线程私有**，否则无法保存当前线程状态的。

2. **虚拟机栈**

Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 **Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。

Java 内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈， 或者说是虚拟机栈中局部变量表部分。(实际上，Java 虚拟机栈是由一个一个栈帧组成，每个栈帧都有**方法索引、输入输出参数、本地变量(局部变量)、引用、父帧、子帧**)，调用函数的所有需要的东西。

每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

![img](C:/Users/chm/Desktop/Java学习/面经.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70.png)

Java 虚 拟 机 会 出 现 两 种 异 常 ：StackOverFlowError 和 OutOfMemoryError

StackOverFlowError:

如果 java 虚拟机栈的内存大小**不允许**动态扩展，那么当线程请求**栈的深度**超**过**当前 Java **虚拟机的最大深度**的时候，就会抛出栈溢出。

OutOfMemoryError：

如果 java 虚拟机栈的内存大小**允许**动态扩展，且当线程请求栈时**内存用完**了，**无法再动态扩展**了，此时抛出 **OutOfMemoryError** 异常。

**如何调用方法\函数**

每一次函数调用都会有一个对应的栈帧压入 java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式： 

- **return 方式**

- **抛出异常**

不管哪种返回方式都会导致栈帧被弹出。

3. **本地方法栈**

本地方法栈和虚拟机栈本质一样，不过是只**存储本地方法**，为本地方法服务。

本地方法被**执行**的时候，在本地方法栈也会**创建**一个**栈帧**，里面包含一个方法所需要的东西(输入输出参数，方法引用，局部变量，父帧，子帧)

出现的错误也跟虚拟机栈一样。

我们在普通类中，写入了方法都需要写方法体的。但是加入了 **Native** 关键字就**不用写方法体**

![img](https://img-blog.csdnimg.cn/20210207010547366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210207010605643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

因为带了 **native** 关键字的说明 **java 的作用范围达不到**了，他会去调用 c 语言的库会进入本地方法栈，**调用本地方法接口** JNI

JNI 作用：**拓展 JAVA 的使用**，拓展其他的语言接口为 java 所用，比如：c/c++

为什么要有这个呢？这就要谈及历史了。当 Java 才出世的时候，C/C++横行程序界，所以为了抱大腿，所以 java 专门开一个栈去配合 C++演出。

在最终的执行中，都是**本地方法栈去执行通过 JNI 接口**。

4. **堆**

创建的**对象实例和数组**保存在**堆内存中**，是被线程**共享**的一块**内存区域**，**垃圾回收**的重要区域，内存中**最大**的一块区域，存了**类的静态变量和字符常量**。

堆是**线程共享的的一片最大区域**。类加载器读取了类文件后，一般会把上面东西放到堆中。**对象实例  数组**

Java 世界中的对象几乎都在堆中创建与回收，这样的**操作是对系统的开销非常大**。所以**JIT 编译和逃逸分析**就出来。

**JIT 编译**：叫**“即时编译**”，某段代码第一次被执行时进行编译。说到编译器就要与解释器一起比较了。

![img](https://img-blog.csdnimg.cn/20210207010753808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

当 java 文件成了字节码了，然后 [jvm](https://so.csdn.net/so/search?q=jvm&spm=1001.2101.3001.7020) 里面一般是有解释器和编译器。

我们可以把解释器想做一个黑盒子，进入一堆代码，返回我们需要的结果。我们每次来了，程序调用解释器，解释器运行后返回结果，很有可能调用的**相同的代码**(比如**循环**)，所以我们编译器就起作用了，将**热点程序编译成本地代码**，我们就直接执行本地代码，就不用一条条解释了。

本地代码又是什么呢？不同操作系统的机器码是不一样的。之所以 JAVA 能有那个响亮的口号”一次编译，到处运行”，是因为 JVM 里面的解释器。解释器将源代码解释成当前系统的机器码，不同版本的 JVM 对应着不同的系统。所以只要系统中下载了 JVM，其他系统的 java 随便运行。但是每条解释也没有编译好的代码快啊。所以就有了 jit 编译。

那么问题来了。到底选用解释器还是 jit 编译器（即时编译器）。那就看**是否为热点程序**，如果只有一条那肯定是解释器快了。
判断是否热点程序的***\*两个方法\****：

- 基于**采样的热点探测**：**周期检查**每个线程的**栈顶方法**，**经常出现**的方法，就是“热点方法”

- 基于**计数器的热点探测**：为每个**方法**建立**计数器**，统计**执行**方法的**次数**，超过一定的次数就认为它是”热点方法” 。包含两个计数器：(1)方法调用计数器；(2)回边计数器。

**逃逸分析：**当一个对象在方法中被定义后，它可能**被外部方法引用**，例如作为调用**传入参数**传递到**其他方法**中，成为**方法逃逸**；有些可能被其他线程访问到，譬如赋值给类变量   或者在**其他线程**中**访问**的实例变量，称为**线程逃逸**。

逃逸分析能分析出一个对象会不会逃逸到方法或线程之外，如果**不会发生逃逸**，那么就会进行一些高效的**优化**：

- **栈上分配**(针对方法逃逸)：将不会逃逸的对象**分配到栈上**，对象随着方法的结束而结束，**减少** **GC 系统**的**压力**
- **同步消除**(针对线程逃逸)：如果其他线程不访问该对象，那么我们可以把**同步措施取消**掉
- **标量替换**：将对象的一个聚合产物分解成多个基本成员变量。这个方法不是创建对象了，直接创建对象里面的成员变量到栈上分配与读写。

Java 堆是 GC 系统的主要区域，现代收集器都是采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细分：Eden、From Survivor、To Survivor 空间。进一步的划分目的是为了***\*更好地回收内存\****，或者更快分配内存。

JDK7 以及之前，堆内存通常被分为下面三个部分：

1.  新生代内存
2.  老年代
3.  永久代

![img](C:/Users/chm/Desktop/Java学习/面经.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70-16572676081502.png)

JDK8 版本之后**方法区**(HotSpot 的**永久代**)被彻底**移除**了,取而代之是元空间，**元空间**使用的是**直接内存**。因为(1)永久代被 JVM 设定了一个大小限制，而元空间直接使用的直接内存受本机可用内存的限制，但是内存溢出的可能性大大减少。(2)JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 没有永久代，合并后也没有必要开一个额外的设置。
![img](https://img-blog.csdnimg.cn/20210207011320421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

大部分的情况，对象都会现在 **Eden** 区域分配，然后进行了一次新生代垃圾回收，如果对象还活着，就进入进入幸存区 0 或 1，并且**年龄**还会**+1**，当它的年龄增到一定程度(默认**15** 岁)，就会到**老年代**。对象晋升到老年代的年龄阈值：可以通过  -XX：MaxTenuringThreshold来设置。

其中还有一个动态对象年龄判断，如果**幸存区中相同年龄的对象**所有**大小之和**超过了**幸存区的空间一半**，那么**大于**等于**该年龄的对象**直接**进入老年区**，无需等到默认年龄。
堆中的最容易出现的是 OOM，但是还是有多种形式：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/20210207011403711.png)

5. **方法区**

   存储已经被虚拟机加载的**类信息**(**构造方法、接口定义、Class 加载模板)**、**常量、静态变量**、即时编译器编译后的代码缓存

   被线程共享，不会频繁GC

   **静态变量(static)、常量(final)、类信息(构造方法、接口定义、Class 加载模板)、运行时的常量池**存在方法区中，但是存在堆内存中的实例变量和方法区无关

   jdk6、7方法区即永久代，jdk8方法区就是元空间

   常量池表

   **调用方法的过程：**

   1. 先将类模板加载，
   2. 将默认的成员加载到常量池，
   3. 调用方法
   4. 去堆进行赋值操作，如果没有赋值，从常量池取

   **运行时常量池**：

   Class文件存放的常量池表的内容将在类加载后存放到方法区的运行时常量池，运行时常量池是方法区的一部分，Class 文件中除了有**类的版本、字段、方法、接口等描述信息**，还有**常量池表(用于存放编译期生成的各种字面值和符号引用**(检查对象是否引用))

   因为常量池是方法区的一部分，自然会收到方法区内存的限制，所以当常量池无法再申请到内存时抛出 OutOfMemoryError 错误

6. 直接内存

   直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。

   显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

## 堆与栈区别

- 申请方式：**栈系统自动申请**，**堆需要手动申请**
- **栈系统分配速度快**，**堆慢**，容易产生**内部碎片**
- **栈空间地址连续**，**堆是不连续的**（链表存储空闲内存地址）
- **堆存对象实例与数组**，关注**存储**；**栈存局部变量表、操作数栈**、关注**运行**
- 大小限制：**栈预先设定好的**，**编译器**即可**确定**，**堆取决于有效虚拟内存**，**运行期**间**确定**

## 为什么有垃圾收集还会有内存泄漏问题

1. **对象**定义**在错误的范围**

   如果**长生命周期的对象**持有**短生命周期的引用**，就可能会出现**内存泄漏**

2. **异常处理不当**

   各种**资源**的**关闭**一定要**放在finally**里面

## **Jvm的直接内存**

直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。

JDK14新加入了**NIO**（New Input/Output）类，引入了一种**基于通道（channel）与缓冲区（Buffer）的I/O方式**，它可以**使用native函数库**直接**分配堆外内存**，然后**通过**一种**存储在java堆中的DirectByteBuffer对象**作为**这块内存的引用**进行操作。这样能在一些场景中显著提高性能，因此避免了在java堆和native堆中来回复制数据。

本机的**直接内存的分配不会受到java堆大小的限制**，受到**本机总内存大小限制**。

直接内存可以由 -XX:MaxDirecrMenorySize指定

直接内存**申请空间耗费更高的性能**

直接内存IO**读写的性能要优于普通的堆内存**

当我们需要**频繁访问大的内存而不是申请和释放空间时**，通过**使用直接内存**可以**提高性能**。

## Java对象创建的过程

1. **类加载检查**

虚拟机遇到一条 new 指令的时候，首先去常量池中检查该对象的符号引用，并检查该引用是否被加载过、初始化过、解析过。如果没有就要去执行类加载过程。

在work类的二进制数据，包含了一个Car类的符号引用，有方法的全名和相关描述符组成。

![image-20220422212849179](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220422212849179.png)

2. **分配内存**

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定。**分配**方式有两种：”**指针碰撞**”和“**空闲列表**”两种，选择那种分配方式由Java 堆是否规整决定，而 Java 堆是否规整又由所采用的**垃圾收集器**是否带有**压缩整理**功能所决定。

- **指针碰撞**

适用场合：堆内存规整(没有内存碎片)的情况(复制算法，标记压缩算法)

原理：用过的内存全部整合到一边，其中用一个指针来分隔，来了一个新对象，指针往没有用过内存的地方移动。

GC 收集器:serial(标记压缩),parallel(serial 的多线程版本)

- **空闲列表**

使用场合：堆内存不规整,有内存碎片(标记清楚算法)

原理：虚拟机会维护一个列表，该列表中会记录那些内存块是可用的，在分配的时候，**找一块足够大的内存块来创建对象实例**，然后更新列表。



**内存分配并发问题**

虚拟机在创建对象的时候要保证线程安全。通常也有两种方式来保证创建对象   是线程安全的：

- **CAS+失败重试：**

CAS 是乐观锁的一种实现。乐观锁是指，它每次都假设没有其他线程来干扰的，如果有线程干扰，那就重新创建，直到创建成功。这样可以保证更新操作的原子性。

- **TLAB:**

为每一个线程预先在 java堆Eden 区域分配一块内存，首先 线程本地分配缓存区（TLAB） 分配，对象的需要的内存大于了 TLAB 提供的，再采用 CAS 进行内存分配。



3. **初始化零值**

当内存分配完成后，虚拟机需要将分配到的**内存空间都初始化为零值**(不包括对象头)，这一步操作**保证**了**对象的实例字段**在 Java 代码中**可以不赋初值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。就跟有些成员变量赋值了，有些没有赋值，那么那    些没有赋值的就是 Null 的道理是一样的。



4. **设置对象头**

初始化完成后，我们需要一个东西去辨认我们这个新创建对象的一些信息。很多事物的基本信息都存在什么头，比如 http，它的大概属性都会存在信息头中，比如请求方式之类的。当然我们这个新创建对象也是一样的，我们就用对象头来存储对象是那个类的实例、类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。



5. **执行init方法**

经过上面 4 步操作后，我们从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序中，对象创建好了，我们都一般还有构造函数去初始化值，所以***init*方法**就起作用   了，把对象按照程序员的意愿来进行初始化，这样 5 步才算把一个真正可用的对象完全产生出来。



## 对象的访问定位有哪两种方式？

我之前讲了创建对象，现在已经有对象了，那我们怎么去访问与使用呢？我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有①***\*使用句柄\****和②***\*直接指针\****两种：

- **句柄**

Java **堆**中将会划分出**一块内存**来作为**句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据**与**类型数据**各自的**具体地址信息**;

对象实例数据（堆）:

​		对象中各个实例字段的数据

对象类型数据（方法区）：

​		对象的类型、父类、实现的接口、方法等

![img](C:/Users/chm/Desktop/Java学习/面经.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70-16572885058164.png)

- **直接指针访问方式**

Reference 中直接存的就是 Java **堆中的对象实例数据**，然后堆中空间里有指向对象类型数据的地址。

![img](https://img-blog.csdnimg.cn/20210207012713337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

使用句柄的好处是 reference 中存储的是稳定的句柄地址，在**对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改**。使用直接指针访问方式最大的好处就是速度快，节省了一次指针定位的时间开销。Hotspot 默认的是直接指针。

## JVM内存分配和回收

Java 是有 JVM 自动管理对象的内存分配和回收。JVM 内存分配是在堆内存上面进行分配，堆内存主要分为以下几个部分：新生代和老年代(元空间属于非堆)；再细分：Eden、From Survivor、To Survivor 空间。进一步的划分目的是为了更好地回收内存，或者更快分配内存。
![img](https://img-blog.csdnimg.cn/20210207012852164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

大部分的情况，对象都会现在 Eden 区域分配，然后进行了一次新生代垃圾回收，如果对象还活着，就进入进入幸存区 0 或 1，并且年龄还会+1，当它的年龄增到一定程度(默认15 岁)，就会到老年代。对象晋升到老年代的年龄阈值：可以通过  -XX：MaxTenuringThreshold来设置。

其中还有一个动态对象年龄判断，如果**幸存区中相同年龄的对象所有大小之和超过了幸存区的空间一半**，那么**大于等于该年龄的对象直接进入老年区**，无需等到默认年龄。



Minor GC 具体流程：

![img](C:/Users/chm/Desktop/Java学习/面经.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70-16572888188336.png)

Eden 区可以存活的对象给 to 区，from 区也给 to 区；然后先对象集中在左图的 to 区，因为谁空谁是 to，所以以前的 from 区变为 to 区，下次一起又进行 Minor GC 的时候，就往右图的 to 放对象了。这样幸存区中是没有内存碎片的。

 From+Eden 的对象大于了 To 区那么会进行 ***\*Minor GC\****，有超过合格年龄的会进入老年区；

***\*Major GC\**** 会在老年代满的时候进行清理；

***\*Full GC\**** 会清理新生区和老年区： 

- **System.gc;**
- 伊甸园区进入**存活区放不下，去老年区也放不下**；
- **gc 线程与用户线程同时执行**，那么**用户线程依旧可能同时产生垃圾**，如果**垃圾较多无法放入预留空间**；
- 新生代的晋升平均大小大于老年代的剩余空间。

## 堆内存中对象分配的基本策略

![img](C:/Users/chm/Desktop/Java学习/面经.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70-16572899093058.png)

1. 对象优先在eden区分配

目前主流的垃圾收集器都是采用分代回收算法，因此需要将堆内存分为新生代和老年代，   这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

大多数情况下，对象在新生代中 Eden 区分配。当 Egen 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.

2. 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象(比如：字符串、数组) 如果对象比较大，那么复制算法效率就比较低下。

3. 长期存活的对象进入老年代

大部分的情况，对象都会现在 Eden 区域分配，然后进行了一次新生代垃圾回收，如果对象还活着，就进入进入幸存区 0 或 1，并且年龄还会+1，当它的年龄增到一定程度(默认15 岁)，就会到老年代。对象晋升到老年代的年龄阈值：可以通过  -XX：MaxTenuringThreshold来设置。

其中还有一个动态对象年龄判断，如果幸存区中相同年龄的对象所有大小之和超过了幸存区的空间一半，那么大于等于该年龄的对象直接进入老年区，无需等到默认年龄。

## JVM判断对象是否死亡（定义为垃圾）

我们进行 GC 收集的时候，不能随便收集啊。所以要判断这个对象是符合”垃圾”对象，才会去回收。

1. **引用计数法**

给对象添加一个引用计数器，每当有一个地方**引用它**，**计数器就加 1**；**当引用失效**，**计数器就减 1**。

![img](https://img-blog.csdnimg.cn/20210207013323159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/2021020701333646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

STEP1：obj1 引用 GcObject 实例 1，实例 1 的引用次数+1，实例 1 的引用次数=1；

STEP2：obj2 引用 GcObject 实例 2，实例 2 的引用次数+1，实例 2 的引用次数=1；

STEP3：GcObject 实例 2 的引用次数+1，实例 2 的引用次数=2；

STEP4：GcObject 实例 1 的引用次数+1，实例 1 的引用次数=2； 然后执行 STEP5，STEP6，内存如下图:

![img](https://img-blog.csdnimg.cn/20210207013412567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

STEP5：obj1 不再引用 GcObject 实例 1，实例 1 的引用次数-1，实例 1 的引用次数=1；

STEP6：obj2 不再引用 GcObject 实例 2，实例 2 的引用次数-1，实例 2 的引用次数=1；

这**两个对象**已经**不可能再被访问**，但是它们因为**互相引用着对方**，此时 **GC 实例 1 和 GC 实例 2 的次数都不为 0**，所以这两个实例所占的**内存得不到释放**，这便产生了**内存泄漏**。

因此不使用引用计数法。

2. **可达性算法**

主流的虚拟机都是采用 **GC Roots Trancing** 算法，比如 Sun 的 Hotspot 虚拟机便是采用该算法。该算法的核心是从 **GC Roots 对象作为起始点**，利用数学中图论只是，途中**可达对象便是存活对象**，而**不可达对象则是需要回收的垃圾内存**。其中涉及到两个重要的概念，GC Roots ，一是可达性。

**GC Roots 的对象(三中其 1)：**

1. **虚拟机的栈帧**的**局部变量表**所引用的对象；

2. **本地方法栈**的 JNI 所引用的对象；
3. **方法区**的**静态变量和常量**所引用的对象；

![img](https://img-blog.csdnimg.cn/20210207013516106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210207013525401.png)

从上图可以看出，1,2,4,6 都可以达到 GC roots，也就是存活对象，不能被 GC 回收。但是对于 3 和 5，他们就涉及不到 GC roots,这就是不可达对象，需要被回收。

总结来说，对于对象之间循环引用的情况，引用计数算法，则 GC 无法回收这两个对象， 但是可达性算法则可以正确回收。

## Jvm堆的内部结构

- 对象实例、数组
- -Xms表示堆初始大小
- -Xmx表示堆最大大小
- 逻辑上连续，线程共享，虚拟机启动时创建，最大
- 没有内存完成对象实例分配，且无法扩展，OOM

![image-20220423162444865](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220423162444865.png)

![image-20220423162538819](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220423162538819.png)

![image-20220423162548390](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220423162548390.png)

![image-20220423162646747](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220423162646747.png)

![image-20220423163212706](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220423163212706.png)

![image-20220423164124406](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220423164124406.png)

## 为什么移除永久代

1. **字符串**存在**永久代**，容易出现**性能问题**和**内存溢出**
2. **类及方法的信息等比较难确定其大小**，因此对于永久代的大小指定比较困难，**太小**容易出现**永久代溢出**，**太大**则容易导致**老年代溢出**。
3. **永久代**会为**GC**带来**不必要的复杂度**，并且**回收效率偏低**
4. Oracle可能会将HotSpot与JRockit合二为一，jrockit中没有永久代概念

## Jvm触发full gc的几种情况？

Full GC会"Stop The World"，即在GC期间全程暂停用户的应用程序

新生对象无法再Eden区创建，就会触发一次Minor GC，此时会进行Minor GC

基本上发生一次Major GC就会发生一次Minor GC，并且Major GC的速度往往比Minor GC慢10倍

大对象放入老年代，老年代放不下时触发Major GC清理老年代的空间，放得下成功，放不下OOM

触发Full GC

1. **调用System.gc()**

   建议虚拟机执行Full GC，但是虚拟机不一定真正去执行，不建议这种方式，而是让虚拟机管理内存

2. **老年代空间不足**

   1. 大对象直接进入老年代（老年代**空间足**，但是**没有足够的连续空间**）
   2. **长期存活的对象直接进入老年代**

   解决：

   1. 尽量**不要创建**过**大的对象及数组**
   2. 可以通过-Xmn**调大新生代大小**，让**对象**尽量在**新生代**被**回收**，不进老年代
   3. **调大**分代**年龄阈值**，让**对象**在**新生代多存活一段时间**

3. **空间分配担保失败**

   在正式 Minor GC 前，JVM 会**先检查新生代中对象**，是比**老年代中剩余空间大还是小**。为什么要做这样的检查呢？原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：

   1. 老年代剩余空间**大于**新生代中的对象大小，那就**直接Minor GC**，GC完survivor不够放，老年代也绝对够放；

   2. 老年代剩余空间**小于**新生代中的对象大小，这个时候就要查看是否启用了“**老年代空间分配担保规则**”，具体来说就是看 -XX:-HandlePromotionFailure 参数是否设置了。

      老年代空间分配担保规则是这样的，如果老年代中剩余空间大小，**大于历次 Minor GC 之后剩余对象的大小**，那就**允许进行 Minor GC**。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：

      老年代中剩余空间大小，大于历次Minor GC之后剩余对象的大小，进行 Minor GC；

      老年代中剩余空间大小，**小于**历次Minor GC之后剩余对象的大小，进行**Full GC**，把**老年代空出来再检查**。

   开启老年代空间分配担保规则只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：

   1. Minor GC 之后的对象**足够**放到 Survivor 区，皆大欢喜，**GC 结束**；
   2. Minor GC 之后的对象**不够**放到 **Survivor 区**，接着进入到老年代，**老年代能放下**，那也可以，GC 结束；
   3. Minor GC 之后的对象**不够放到 Survivor 区**，**老年代也放不下**，那就只能 **Full GC**。

   前面都是成功 GC 的例子，还有 3 中情况，会导致 GC 失败，报 OOM：

   1. 紧接上一节 **Full GC 之后**，**老年代仍然放不下剩余对象**，就只能 **OOM**；
   2. **未开启老年代分配担保机制**，且**一次 Full GC** 后，**老年代任然放不下剩余对象**，也只能 OOM；
   3. **开启老年代分配担保机制**，但是**担保不通过**，**一次 Full GC** 后，**老年代仍然放不下剩余对象**，也是能 OOM。

## 如何减少FullGC的次数？

当 **Eden 区的空间耗尽**时 Java 虚拟机便会**触发一次 Minor GC** 来收集新生代的垃圾，存活下来的对象，则会被送到 Survivor 区，简单说就是当新生代的Eden区满的时候触发 Minor GC。

serial GC 中，老年代内存剩余已经小于之前年轻代晋升老年代的平均大小，则进行 Full GC。而在 CMS 等并发收集器中则是每隔一段时间检查一下老年代内存的使用量，超过一定比例时进行 Full GC 回收。

可以采用以下措施来减少Full GC的次数：

1. **增加方法区**的空间；
2. **增加老年代**的空间；
3. **减少新生代**的空间；
4. **禁止使用System.gc()**方法；
5. 使用**标记-整理**算法，尽量**保持较大的连续内存空间；**
6. **排查代码中无用的大对象。**

## Jvm判断对象是否可以被回收

**1. 引用计数法**

此种算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就+1，取消对这个对象的引用时，计数器就-1。任何一个时刻，如果该对象的计数器为0，那么这个对象就是可以回收的。

```java
public static void method() {
    A a = new A();
}

public static void main(String[] args) {
    method();
}
```

main函数调用method方法，method方法中new了一个A的对象，赋值给局部变量a，此时堆内存中的对象A的实例的计数器就会+1。当方法结束时，局部变量会随之销毁，堆内存中的对象的计数器就会-1。

**存在问题**

该算法存在两个问题： ***无法处理循环引用**的情况。* 从上述的原理可知，堆内对象的每一次引用赋值和每一次引用清除，都伴随着加减法的操作，会带来一定的性能开销。

即对象A引用对象B，对象B引用对象A。

```java
class A {
    private B b;
    public void setB(B b) {
        this.b = b;
    }
}

class B {
    private A a = new A();
    public void setA(A a) {
        this.a = a;
    }
}

public void method() {
    A a = new A();
    B b = new B();
    a.setB(b);
    b.setA(a);
}
```

![img](https://pic1.zhimg.com/80/v2-3663b4c2a7c8eb93e9e19da45dc31ac8_720w.jpg)

method方法中，执行完两个set后，method方法结束，图中两条红线引用消失，可以看到，留下两个对象在堆内存中循环引用，但此时已经没有地方在用他们了，造成**内存泄漏**。两个对象就凌乱在风中不知所措了。

**2. 可达性分析**

为了解决引用计数的循环引用问题。java使用了可达性分析的方法。通过一系列的”GC roots“对象作为起点搜索。如果在”GC roots“和一个对象之间没有可达路径，则称该对象是不可达的。

不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程，如果两次标记后仍然是可回收对象，则将面临回收。

可作为GC root的对象有：

- java虚拟机栈（栈帧的本地变量表）中引用的对象。
- 本地方法栈中JNI引用的对象。
- 方法区中常量、类静态属性引用的对象。

## 内存泄漏和内存溢出有什么区别？

内存泄漏（memory leak）：内存泄漏指**程序运行**过程中**分配内存给临时变量**，**用完**之后却**没有被GC回收**，始终占用着内存，既**不能被使用**也**不能分配给其他程序**，于是就发生了**内存泄漏**。

内存溢出（out of memory）：简单地说内存溢出就是指**程序运行过程**中**申请的内存大于系统能够提供的内存**，导致**无法申请到足够的内存**，于是就发生了内存溢出。

## 什么是内存泄漏，怎么解决？

内存泄漏的根本原因是**长生命周期的对象持有短生命周期对象的引用**，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。以发生的方式来分类，内存泄漏可以分为4类：

1. **常发性**内存泄漏。发生内存泄漏的代码会被**多次执行到**，每次被执行的时候都会导致一块内存泄漏。
2. **偶发性**内存泄漏。发生内存泄漏的代码**只有在某些特定环境或操作过程下才会发生**。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
3. **一次性**内存泄漏。发生内存泄漏的代码**只会被执行一次**，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
4. **隐式**内存泄漏。**程序在运行过程中不停的分配内存**，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

避免内存泄漏的几点建议：

1. 尽早**释放无用对象的引用**。
2. **避免**在**循环中创建对象**。
3. 使用字符串处理时**避免使用String**，应**使用StringBuffer**。
4. 尽量**少使用静态变量**，因为静态变量**存放在永久代**，基本**不参与垃圾回收**。

## 什么是内存溢出，怎么解决？

内存溢出（out of memory）：简单地说内存溢出就是指**程序运行过程中申请的内存大于系统能够提供的内存**，**导致无法申请到足够的内存**，于是就发生了内存溢出。

引起内存溢出的原因有很多种，常见的有以下几种：

1. **内存中加载的数据量过于庞大**，如一次从数据库取出过多数据；
2. 集合类中有**对对象的引用，使用完后未清空**，使得JVM不能回收；
3. 代码中存在**死循环或循环产生过多重复的对象实体**；
4. 使用的第三方软件中的BUG；
5. 启动参数内存值设定的过小。

内存溢出的解决方案：

- 第一步，**修改JVM启动参数，直接增加内存**。
- 第二步，**检查错误日志**，查看“OutOfMemory”错误前是否有其它异常或错误。
- 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
- 第四步，使用内存查看工具动态查看内存使用情况。

## 哪些区域会OOM，怎么触发OOM？

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。

1. **Java堆溢出**

   Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

2. 虚拟机栈和本地方法栈溢出

   HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。

3. 方法区和运行时常量池溢出

   方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。

   在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法区的一部分，所以上述问题在常量池中也同样会出现。而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免。

4. 本地**直接内存溢出**

   直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常

## 强引用、软引用、弱引用、虚引用

**强引用**

无论是通过引用计数法判断引用数量，还是通过可达性分析判断对象的引用是否可达，判断对象的存活都与”引用”有关。

如果一个对象具有**强引用**，对于我们来说是***\*不能缺少的对象\****，***\*垃圾回收器\****绝不会回收它。

当内存空间不足，JVM 宁可抛出异常也不会回收它。例子：list 集合里的数据不会释放，即使内存不足也不会。

![img](https://img-blog.csdnimg.cn/2021020701372374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

**软引用**

软引用的对象是可有可无的对象。如果**内存空间足够**，垃圾回收器就**不会回收**它，如果**内存空间不足**了，就会**回收这些对象的内存**。只要垃圾回收器没有回收它，该对象就可以被程序使用。

**软引用**与一个**引用队列联合使用**，如果软引用的对象被垃圾回收，JAVA 虚拟机就会把这个**软引用加入与之关联的引用队列**中。当内存足够大时可以把数组存入软引用，取数据就可以从内存里取数据，提交效率。例子：浏览器的后退按钮![img](https://img-blog.csdnimg.cn/20210207013928510.png)

**弱引用**

弱引用的对象也是可有可无的对象。弱引用于软引用的区别在于：垃圾回收器在扫描他所    管辖的内存区域，一旦发现弱引用的对象，**不管内存是否足够**，**都会回收它的内存**。不过垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

**弱引用**与一个**引用队列联合使用**，如果**软引用的对象被垃圾回收**，JAVA 虚拟机就会把这个弱引用**加入与之关联的引用队列**中。

当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这个时候就是弱引用。

**虚引用**

虚引用并**不会决定对象的生命周期**。他跟没有任何引用一样，在**任何时候都可能被垃圾回收**。

虚引用主要用来**跟踪对象被垃圾回收的活动**。 **虚引用必须和引用队列联合使用**。

![img](https://img-blog.csdnimg.cn/20210207014126355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

## 判断一个常量是废弃常量

假如在常量池中存在**字符串”abc”**，如果当前**没有任何 String 对象引用该字符串常量**的话，

就说明常量”abc”就是**废弃常量**，如果**此时发生内存回收**的话，**”abc”就会被系统清理出常量池**。

## 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的呢？

如果要判断是无用的类要同时满足以下三个条件：

- 该类的**所有实例都被回收**，也就是说 Java 堆中**没有该类的任何对象**
- 加载**该类的 ClassLoader** 已经被回收
- 该类对应的 java.lang**.Class 对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

## JVM中一次完整的GC流程是怎样的？

新创建的对象一般会被分配在新生代中，常用的新生代的垃圾回收器是 ParNew 垃圾回收器，它按照 **8:1:1** 将新生代分成 **Eden 区，以及两个 Survivor 区**。某一时刻，我们创建的对象将 **Eden 区全部挤满**，这个对象就是挤满新生代的最后一个对象。此时，**Minor GC 就触发**了。

在正式 Minor GC 前，JVM 会**先检查新生代中对象**，是比**老年代中剩余空间大还是小**。为什么要做这样的检查呢？原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：

1. 老年代剩余空间**大于**新生代中的对象大小，那就**直接Minor GC**，GC完survivor不够放，老年代也绝对够放；

2. 老年代剩余空间**小于**新生代中的对象大小，这个时候就要查看是否启用了“**老年代空间分配担保规则**”，具体来说就是看 -XX:-HandlePromotionFailure 参数是否设置了。

   老年代空间分配担保规则是这样的，如果老年代中剩余空间大小，**大于历次 Minor GC 之后剩余对象的大小**，那就**允许进行 Minor GC**。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：

   老年代中剩余空间大小，大于历次Minor GC之后剩余对象的大小，进行 Minor GC；

   老年代中剩余空间大小，**小于**历次Minor GC之后剩余对象的大小，进行**Full GC**，把**老年代空出来再检查**。

开启老年代空间分配担保规则只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：

1. Minor GC 之后的对象**足够**放到 Survivor 区，皆大欢喜，**GC 结束**；
2. Minor GC 之后的对象**不够**放到 **Survivor 区**，接着进入到老年代，**老年代能放下**，那也可以，GC 结束；
3. Minor GC 之后的对象**不够放到 Survivor 区**，**老年代也放不下**，那就只能 **Full GC**。

前面都是成功 GC 的例子，还有 3 中情况，会导致 GC 失败，报 OOM：

1. 紧接上一节 **Full GC 之后**，**老年代任然放不下剩余对象**，就只能 **OOM**；
2. **未开启老年代分配担保机制**，且**一次 Full GC** 后，**老年代任然放不下剩余对象**，也只能 OOM；
3. **开启老年代分配担保机制**，但是**担保不通过**，**一次 Full GC** 后，**老年代任然放不下剩余对象**，也是能 OOM。

## Jvm垃圾回收算法

1. 标记-清除算法

第一步：扫描，标记出不需要清除的对象

第二步：对没有标记的对象，进行清除

![img](https://img-blog.csdnimg.cn/20210207014413367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjYyMzcy,size_16,color_FFFFFF,t_70)

- 效率问题(扫描了两次，浪费时间)
- 空间问题(产生了大量的内存碎片)



![image-20220424102423660](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220424102423660.png)

![image-20220424102533538](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220424102533538.png)

![image-20220424102643741](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424102643741.png)

![image-20220424102733017](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220424102733017.png)

![image-20220424102828084](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424102828084.png)

![image-20220424102932076](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424102932076.png)

## 新生代为什么要分为Eden和Survivor，它们的比例是多少？

该算法早期采用“**半区复制**”的机制进行垃圾回收。将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，**空间浪费**未免太多了一点。

实际上，新生代中的对象有**98%**熬不过第一轮收集，因此并不需要按照1∶1的比例来划分新生代的内存空间。HotSpot虚拟机默认Eden和Survivor的大小比例是**8∶1**，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即**10%的新生代**是会被**“浪费”**的。

## 什么要设置两个Survivor区域？

设置两个 Survivor 区最大的好处就是解决内存碎片化。

Survivor 只有一个区域会怎样。Minor GC 执行后，**Eden 区被清空**了，**存活的对象放到了 Survivor 区**，而之前 **Survivor 区中的对象，可能也有一些是需要被清除**的。问题来了，这时候我们怎么清除它们？在这种场景下，我们**只能标记清除**，而我们知道标记清除最大的问题就是**内存碎片**，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 **Survivor 有 2 个区域**，所以每次 Minor GC，会**将之前 Eden 区和 From 区中的存活对象复制到 To 区域**。第二次 Minor GC 时，**From 与 To 职责兑换**，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，**以此反复**。

这种机制最大的好处就是，整个过程中，**永远有一个 Survivor space 是空的**，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区**再细分下去**，每一块的**空间就会比较小**，容易**导致 Survivor 区满**，两块 Survivor 区可能是经过权衡之后的最佳方案。

## 为什么老年代不能使用标记复制？

因为老年代保留的**对象**都是**难以消亡**的，而**标记复制算法**在**对象存活率较高时**就要进行**较多的复制操作**，**效率将会降低**，所以在老年代一般不能直接选用这种算法。

## 为什么区分新生区和老年区

为了提升 GC 效率，因为不同区使用不同的 GC 算法。

## 为什么新生代和老年代要采用不同的回收算法？

如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间。如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

## java的引用类型

![image-20220424104340650](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424104340650.png)

![image-20220424104350684](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424104350684.png)

​                 **虚引用**

![image-20220424104510973](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424104510973.png)

## Jvm垃圾回收器

![image-20220424105022342](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424105022342.png)

![image-20220424105046888](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424105046888.png)

**下面为老年代的垃圾回收器**

![image-20220424163156093](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424163156093.png)

![image-20220424163212808](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424163212808.png)

![image-20220424163220808](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424163220808.png)

### CMS 

1. **初始标记**：标记GC Roots直达的对象，需要**暂停**所有的工作线程
2. **并发标记**：跟踪标记Gc Roots所有可达对象，不需要暂停所有的工作线程
3. **重新标记**：重新标记那些由于并发标记中用户程序执行导致发生变化的对象，需要**暂停**所有的工作线程
4. **并发清除**：清除标记垃圾，不需要暂停所有的工作线程

由于耗时最长的**并发标记**和**并发清除**可以**与用户一起并发工作**，所以总体上看，**CMS收集器的内存回收和用户线程是一起并发的执行**。

优点：支持并发，停顿时间短

缺点：使用标记清除算法，空间碎片，空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。并发标记产生**浮动垃圾**

**浮动垃圾**

并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描,所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从`GC Root`中去找到，所以成为了浮动垃圾，**浮动垃圾对系统的影响不大，留给下一次GC进行处理即可**。

### G1

**弱化分代**（老年代与年轻代一起回收，引入分区，将堆分为多个大小相等区域分而治之）把连续的**Java堆划分**为多个**大小相等**的**独立区域**，每一个**Region**都可以**根据需要**，**扮演新生代的Eden空间、Survivor空间，或者老年代空间**。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数 -XX：G1HeapRegionSize 设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待，如下图所示。

1. **初始标记**：标记GC Roots直达的对象，需要**暂停**所有的工作线程
2. **并发标记**：跟踪标记Gc Roots所有可达对象，不需要暂停所有的工作线程
3. **重新标记**：重新标记那些由于并发标记中用户程序执行导致发生变化的对象，需要**暂停**所有的工作线程
4. **筛选回收**：对各个region区域进行**回收价值与成本的排序**，根据**用户期望的GC停顿时间来执行计划**（**最少时间**回收**最多垃圾区域**，**停顿用户线程**）

特点：

- 空间整合：整体来看是基于”标记-整理“算法实现的收集器，从局部（两个region之间）上来看是基于复制算法实现的，这意味着运行期间不会产生内存空间碎片
- 可预测的停顿：能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒

## CMS与G1的区别

**CMS**用在**老年代**，**G1**应用范围**新生代与老年代**

**CMS**注重**低延迟**，**G1可预测的停顿**

**CMS**使用**标记清除算法**，造成**内存空间碎片**；**G1**进行空间整合使用**标记-整理**，**不会有内存空间碎片**



## jdk7、8、9默认垃圾回收器

![image-20220424164448338](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424164448338.png)

## Jvm调优配置

JVM 调优的目标是：使用较小的内存占用来获得较高的吞吐量或者较低的延迟。重要指标：

内存占用：程序正常运用需要的内存大小
延迟：由于垃圾收集而引起的程序停顿时间
吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值
当然这个跟分布式系统中的 CAP 原则一样，不能同时达到，所以我们应用的场景不同， 那么调优所考虑的方向也不同。

**调优经验**

JVM 配置方面，可以先使用默认配合，**堆初始是内存的 1/16,最大堆内存是内存的 1/4**。然后在测试中根据系统的运行情况，结合 GC 日志、内存监控、使用的垃收集器等机型合理的调整，比如：当老年代内存过小时可能引起频繁的 Full GC,当内存过大时 Full GC 时间又会特别长。

物理内存一定的条件下，***\*新生代\****设置***\*越大\****，老年代就***\*越小\****，Full GC ***\*频率越高\****，但是 Full GC 时间越短；相反新生代设置越小，老年代就越大，Full GC 频率就***\*越低\****，但每次 Full GC 消耗的***\*时间越大\****。所以要找到自己场景适合的合适点。

**调优建议**

1. -Xms 和-Xmx 的值设置一样，为了避免内存的动态调整，因为当空闲堆内存不同的时候， 会切换-Xms 和-Xmx 内存状态，如果设置一样的话，就不会进行动态内存调整，节约资源。
2. 新生代尽量设置大一些，让对象在新生代多存活一段时间，每次 Minor GC 进可能多收集垃圾对象，防止进入老年代，进行 Full GC.
3. 老年代如果使用 CMS 收集器，新生代可以不用太大，因为 CMS 的并发收集速度也很快， 收集过程可以与用户线程并发执行。

**避免以下问题**

1. 避免**创建过大的对象或者数组**：过大的对象和数组在新生代没有足够的空间会进入，老年代，会提前出发 FullGC
2. 避免**同时加载大量数据**：从数据库或者 Excel 取大量数据，尽量分批读取
3. 当程序中**有对象引用**，如果**使用完**后，尽量**设置为 null**，比如 obj1=null。避免这些对象进入老年代
4. 避免**长时间等待外部资源**，缩小对象的生命周期，避免进入老年代。

![image-20220424170013156](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220424170013156.png)

![image-20220424170023245](C:/Users/chm/Desktop/Java学习/面经.assets/image-20220424170023245.png)

![image-20220424170048548](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424170048548.png)

![image-20220424195856213](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424195856213.png)

![image-20220424195901574](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424195901574.png)

## Java的osgi是什么

![image-20220424200024121](C:\Users\chm\AppData\Roaming\Typora\typora-user-images\image-20220424200024121.png)

## 内存持续上升，如何处理

1. 启动程序前开启对**内存异常日志**

2. 从日志中发现异常
3. 通过top命令查看**进程cpu使用率**
4. 查看进程下**具体线程占用系统资源情况**
5. 查看具体线程的**堆栈信息**
6. 查看**堆内存的使用情况**